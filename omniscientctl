jeremy@raspberrypi:~$ cat /usr/local/bin/omniscientctl
#!/usr/bin/env bash
set -Eeuo pipefail

# ===== Omniscient Master CLI (generated) =====
# Build time: '"$STAMP"'
# This file is generated by /opt/omniscient/tools/merge_omniscientctl.sh
# DO NOT edit here; edit sources, then rerun the merger.

MODULE_DIR="/opt/omniscient/control/omniscientctl.d"
PYTHON_MODULE_DIR="/opt/omniscient/control/modules"
declare -A MODULES=()

# -- Load modules (no execution side effects expected; each file should only define funcs/vars)
if [[ -d "$MODULE_DIR" ]]; then
  for _m in "$MODULE_DIR"/mod_*.sh; do
    [[ -f "$_m" ]] || continue
    # shellcheck source=/dev/null
    source "$_m"
    _n="${_m##*/mod_}"; _n="${_n%.sh}"
    MODULES["$_n"]="mod_${_n}"
  done
fi

# ===== Authoritative completion gateway (ALWAYS before dispatcher) =====
if [[ "${1:-}" == "__comp" ]]; then
  __comp_kind="${2:-}"; shift 2 || true

  _comp_echo_engines() {
    local out=()
    command -v ollama >/dev/null 2>&1 && out+=("ollama")
    if command -v openai >/dev/null 2>&1 || [[ -n "${OPENAI_API_KEY:-}" ]]; then out+=("openai"); fi
    if command -v python3 >/dev/null 2>&1 && [[ -f "$PYTHON_MODULE_DIR/ai/tools/run_gpt4all_prompt.py" ]]; then out+=("gpt4all"); fi
    [[ ${#out[@]} -eq 0 ]] && out=(ollama openai gpt4all)
    printf "%s\n" "${out[*]}"
  }
  _comp_echo_devices() {
    if command -v lsblk >/dev/null 2>&1; then
      lsblk -rno NAME,TYPE 2>/dev/null | awk '$2=="part"||$2=="disk"{printf "/dev/%s ",$1}'
    fi
  }
  _comp_top_subs() {
    # Keep in sync with dispatcher registrations
    echo "help verify-completion backbone bootstrap mysql rsyslog drives prompt summarize install update backup start stop restart exec launch gui streamlit launch-ui omnieye shell-review version legend pick logs migrate"
    # module names also count as subcommands
    for k in "${!MODULES[@]}"; do printf "%s " "$k"; done
  }
  _comp_group_subs() {
    case "$1" in
      backbone)  echo "init update status open scaffold push" ;;
      bootstrap) echo "env bashrc manpages ai-docs integrity omnilog all" ;;
      mysql)     echo "setup status" ;;
      rsyslog)   echo "setup stream" ;;
      drives)    echo "scan mount unmount" ;;
      *)         echo "" ;;
    esac
  }
  _comp_base_opts(){ echo "--help --version --verbose --config --force"; }
  _comp_opts_for(){
    local first="$1"
    case "$first" in
      prompt) echo "--help --verbose --config --force" ;;
      backbone|bootstrap|mysql|rsyslog|drives) echo "--help --verbose" ;;
      *)
        if [[ -n "${MODULES[$first]:-}" ]] && declare -f "mod_${first}__comp" >/dev/null; then
          "mod_${first}__comp" opts || true
        else
          _comp_base_opts
        fi
        ;;
    esac
  }

  case "$__comp_kind" in
    engines)  _comp_echo_engines;   exit 0;;
    devices)  _comp_echo_devices;   exit 0;;
    subs)
      ctx="${1:-}"
      if [[ -z "$ctx" ]]; then _comp_top_subs; exit 0; fi
      grp="$(_comp_group_subs "$ctx")"
      if [[ -n "$grp" ]]; then echo "$grp"; exit 0; fi
      if [[ -n "${MODULES[$ctx]:-}" ]] && declare -f "mod_${ctx}__comp" >/dev/null; then
        "mod_${ctx}__comp" subs || true; exit 0
      fi
      echo ""; exit 0;;
    opts)
      first="${1:-__base}"
      if [[ "$first" == "__base" ]]; then _comp_base_opts; exit 0; fi
      _comp_opts_for "$first"; exit 0;;
  esac
  exit 0
fi


# ===== BEGIN: /opt/omniscient/dev/control/dropoff/merge_control_funcs.sh =====
#!/usr/bin/env bash

# === CONFIGURATION ===
CONTROL_DIR="./control"
MAIN_SCRIPT="$CONTROL_DIR/omniscientctl"
ALT_SCRIPT="$CONTROL_DIR/omniscientctl2"
BACKUP_DIR="$CONTROL_DIR/backups"
LOG_FILE="$CONTROL_DIR/omniscientctl_merge.log"
TMP_FUNCS="/tmp/omniscientctl_new_funcs.tmp"

# === SAFETY CHECKS ===
mkdir -p "$BACKUP_DIR"

[[ ! -f "$MAIN_SCRIPT" ]] && echo "[ERROR] Main omniscientctl script not found at: $MAIN_SCRIPT" && exit 1
[[ ! -f "$ALT_SCRIPT" ]] && echo "[ERROR] Alternate script not found at: $ALT_SCRIPT" && exit 1

echo "[INFO] Working from directory: $CONTROL_DIR"
echo "[INFO] Backups will be saved to: $BACKUP_DIR"

# === BACKUP MAIN SCRIPT ===
timestamp=$(date +"%Y%m%d_%H%M%S")
cp "$MAIN_SCRIPT" "$BACKUP_DIR/omniscientctl.bak.$timestamp"
echo "[BACKUP] Original omniscientctl backed up as omniscientctl.bak.$timestamp"

# === FUNCTION NAME EXTRACTOR ===
extract_func_names() {
  grep -E '^\s*(function\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)\s*\{' "$1" \
  | sed -E 's/^\s*(function\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\).*/\2/' \
  | sort -u
}

# === GATHER FUNCTION NAMES ===
main_funcs=$(extract_func_names "$MAIN_SCRIPT")
alt_funcs=$(extract_func_names "$ALT_SCRIPT")

# === FIND NEW FUNCTIONS ONLY ===
new_funcs=()
while IFS= read -r func; do
  if ! grep -q -E "^\s*(function\s+)?$func\s*\(\)\s*\{" "$MAIN_SCRIPT"; then
    new_funcs+=("$func")
  fi
done <<< "$alt_funcs"

# === HANDLE NO NEW FUNCTIONS ===
if [[ ${#new_funcs[@]} -eq 0 ]]; then
  echo "[OK] No new functions found. Everything is synced."
  exit 0
fi

# === EXTRACT FUNCTION BODIES ===
> "$TMP_FUNCS"
for func in "${new_funcs[@]}"; do
  awk "/^\s*(function\s+)?$func\s*\(\)\s*\{/,/^\}/" "$ALT_SCRIPT" >> "$TMP_FUNCS"
  echo "" >> "$TMP_FUNCS"
done

# === PREVIEW CHANGES ===
echo "[INFO] New functions to merge: ${#new_funcs[@]}"
printf '  - %s\n' "${new_funcs[@]}"

# === PROMPT USER ===
read -rp "Append these functions to $MAIN_SCRIPT? [y/N]: " confirm
[[ "$confirm" =~ ^[Yy]$ ]] || { echo "[ABORTED] Merge canceled."; exit 1; }

# === APPEND NEW FUNCTIONS ===
{
  echo ""
  echo "### === BEGIN MERGED FUNCTIONS from $ALT_SCRIPT @ $timestamp ==="
  cat "$TMP_FUNCS"
  echo "### === END MERGED FUNCTIONS ==="
} >> "$MAIN_SCRIPT"

# === LOG THE MERGE ===
{
  echo "=== Merge @ $timestamp ==="
  echo "From: $ALT_SCRIPT"
  echo "To:   $MAIN_SCRIPT"
  echo "Added functions:"
  printf " - %s\n" "${new_funcs[@]}"
  echo "Backup: omniscientctl.bak.$timestamp"
  echo "============================="
} >> "$LOG_FILE"

echo "[DONE] Merged ${#new_funcs[@]} functions into $MAIN_SCRIPT"
echo "[LOG] See: $LOG_FILE"

# ===== END: /opt/omniscient/dev/control/dropoff/merge_control_funcs.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/dropoff/copilot_migrations_script.sh =====
#!/usr/bin/env bash
# Omniscient Project Migration Script

set -e

OMNIROOT="/opt/omniscient"

# Create directories
mkdir -p "$OMNIROOT/bin"
mkdir -p "$OMNIROOT/core"
mkdir -p "$OMNIROOT/modules"
mkdir -p "$OMNIROOT/plugins"
mkdir -p "$OMNIROOT/scripts"
mkdir -p "$OMNIROOT/logs"
mkdir -p "$OMNIROOT/conf"
mkdir -p "$OMNIROOT/venv"
mkdir -p "$OMNIROOT/ai"
mkdir -p "$OMNIROOT/omnieye"
mkdir -p "$OMNIROOT/readme"
mkdir -p "$OMNIROOT/control/omniscientctl.d"
mkdir -p "$OMNIROOT/data"

# Move main CLI and core library
mv ./omniscientctl "$OMNIROOT/bin/" 2>/dev/null || echo "omniscientctl not found or already moved"
mv ./lib/omniscient-core.sh "$OMNIROOT/core/" 2>/dev/null || echo "omniscient-core.sh not found or already moved"

# Move config and logs
mv ./omniscient.conf "$OMNIROOT/conf/" 2>/dev/null || echo "omniscient.conf not found or already moved"
mv ./logs/* "$OMNIROOT/logs/" 2>/dev/null || echo "No logs to move"

# Move modules, plugins, scripts
mv ./modules/* "$OMNIROOT/modules/" 2>/dev/null || echo "No modules to move"
mv ./plugins/* "$OMNIROOT/plugins/" 2>/dev/null || echo "No plugins to move"
mv ./scripts/* "$OMNIROOT/scripts/" 2>/dev/null || echo "No scripts to move"

# Move AI, omnieye, readme, control extensions, data
mv ./ai/* "$OMNIROOT/ai/" 2>/dev/null || echo "No AI files to move"
mv ./omnieye/* "$OMNIROOT/omnieye/" 2>/dev/null || echo "No omnieye files to move"
mv ./readme/* "$OMNIROOT/readme/" 2>/dev/null || echo "No readme files to move"
mv ./control/omniscientctl.d/* "$OMNIROOT/control/omniscientctl.d/" 2>/dev/null || echo "No control extensions to move"
mv ./data/* "$OMNIROOT/data/" 2>/dev/null || echo "No data files to move"

echo "Migration complete. Please update script source paths as needed."
# ===== END: /opt/omniscient/dev/control/dropoff/copilot_migrations_script.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/dropoff/merge_compile_code.sh =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK HOOKS ────────────────────────────────────────────
# Load environment variables if sourced or run in isolated shell
[ -f /opt/omniscient/.bashrc ] && source /opt/omniscient/.bashrc

# Define key paths directly (if .bashrc isn't sourced)
OMNISCIENT="/opt/omniscient"
OMNISCIENT_LOGS="$OMNISCIENT/logs"
OMNISCIENT_HOME="$OMNISCIENT/home/$USER"
WHITERABBIT="$OMNISCIENT/ai/models/WhiteRabbitNeo-2.5-Qwen<attempt_completion>
<result>
I have reviewed the requested omniscientctl content to include the OMNISCIENT FRAMEWORK HOOKS section with environment variable loading and logging functions. However, the file edit failed due to size or formatting constraints.

Please confirm if you want me to proceed with incremental patch updates or provide the full updated omniscientctl file content in smaller parts for successful integration.

Additionally, please specify your preferred level of testing for the consolidated omniscientctl script:
- Critical-path testing (key elements only)
- Thorough testing (complete coverage)

This will ensure the final implementation is verified according to your requirements.
</result>
</attempt_completion>


#!/bin/bash
# omniscientctl: Central management utility for Omniscient Framework

# Load environment variables
source /opt/omniscient/.autoenv/activate.sh

# Log file
LOGFILE="$PROMPT_LOG"

# Function: Log actions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$LOGFILE"
}

# Function: Display menu
show_menu() {
  echo "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Show system status"
  echo "6) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) show_status;;
    6) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

# Function: View core Omniscient environment variables
view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

# Function: Run AI summary process (mock/demo)
run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "Summary written to: $SUMMARY_LOG"
  echo "" >> "$SUMMARY_LOG"
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

# Function: Trigger maintenance job manually
trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

# Function: Start core services
start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

# Function: Show system status
show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"
  df -h | grep -E '/$|/opt|/var'
  echo "Memory:"
  free -h | grep -v Swap
  show_menu
}

# Entry point
clear
show_menu


import os
import paramiko
import difflib
import hashlib
from datetime import datetime

# === CONFIG ===
REMOTE_HOST = "192.168.1.10"
USERNAME = "user"
KEY_FILE = "~/.ssh/id_rsa"  # SSH key or set to None
FILES_TO_FIND = [
    "$HOME/.bashrc",
    "$HOME/.bashrc_aliases",
    "$HOME/.profile",
    "/etc/bash.bashrc",
    "/etc/profile",
    "/etc/environment"
]

USE_AI_SUMMARY = False

# === AI Optional ===
if USE_AI_SUMMARY:
    from transformers import pipeline
    summarizer = pipeline("summarization", model="facebook/bart-large-cnn")

def resolve_home_path(path, home_dir):
    return path.replace("$HOME", home_dir)

def sha256sum(path):
    if not os.path.exists(path): return None
    h = hashlib.sha256()
    with open(path, 'rb') as f: h.update(f.read())
    return h.hexdigest()

def backup_file(path):
    if os.path.exists(path):
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        os.rename(path, f"{path}.bak.{ts}")
        print(f"[📦] Backup created: {path}.bak.{ts}")

def compare_and_merge(local_path, remote_data, rel_path):
    if not os.path.exists(local_path):
        print(f"[+] New file will be created: {rel_path}")
        return remote_data.decode()

    with open(local_path, "r") as f:
        local_data = f.readlines()
    remote_lines = remote_data.decode().splitlines(keepends=True)

    diff = list(difflib.unified_diff(local_data, remote_lines, fromfile='local', tofile='remote'))

    if diff:
        print(f"[🔀] Difference found in {rel_path}")
        print(''.join(diff))

        if USE_AI_SUMMARY:
            summary = summarizer(''.join(diff), max_length=100, min_length=30, do_sample=False)
            print("🧠 AI Summary:", summary[0]['summary_text'])

        return ''.join(remote_lines)
    else:
        print(f"[-] No differences in: {rel_path}")
        return None

def fetch_and_compare_files():
    print(f"[🔐] Connecting to {USERNAME}@{REMOTE_HOST} via SSH...")
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(REMOTE_HOST, username=USERNAME, key_filename=os.path.expanduser(KEY_FILE))

    stdin, stdout, stderr = ssh.exec_command("echo $HOME")
    remote_home = stdout.read().decode().strip()
    local_home = os.path.expanduser("~")

    sftp = ssh.open_sftp()

    for raw_path in FILES_TO_FIND:
        remote_path = resolve_home_path(raw_path, remote_home)
        local_path = resolve_home_path(raw_path, local_home)

        print(f"\n[📁] Checking: {raw_path}")
        try:
            remote_file = sftp.file(remote_path, 'r')
            remote_data = remote_file.read()

            new_data = compare_and_merge(local_path, remote_data, raw_path)
            if new_data:
                backup_file(local_path)
                os.makedirs(os.path.dirname(local_path), exist_ok=True)
                with open(local_path, 'w') as f:
                    f.write(new_data)
                print(f"[✅] Updated local file: {local_path}")

        except Exception as e:
            print(f"[❌] Error with {raw_path}: {e}")

    ssh.close()
    print("\n[✔] Sync finished.\n")

if __name__ == "__main__":
    fetch_and_compare_files()


#!/bin/bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Auto-source the environment
[ -f /opt/omniscient/.env ] && source /opt/omniscient/.env

OMNIROOT="/opt/omniscient"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"

# Load config values with crudini if available
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
    MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
    LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
    OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
    MODEL="gpt4all"
    LOG_LEVEL="INFO"
    OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
    for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# --------------------------
# Module auto-registration
# --------------------------
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
    for mod_file in "$MODULE_DIR"/mod_*.sh; do
        [[ -f "$mod_file" ]] || continue
        mod_basename=$(basename "$mod_file" .sh)
        mod_name=${mod_basename#mod_}

        # Check if module enabled in config (default true)
        enabled="true"
        if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
            enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
        fi

        if [[ "$enabled" == "true" ]]; then
            source "$mod_file"
            MODULES["$mod_name"]="mod_${mod_name}"
        fi
    done
fi

# --------------------------
# Helper functions
# --------------------------

show_help() {
    echo -e "\nOmniscient CLI Usage:\n"
    echo "  omniscientctl <command> [args...]"
    echo
    echo "Available commands from modules:"
    for cmd in "${!MODULES[@]}"; do
        help_func="mod_${cmd}_help"
        if declare -f "$help_func" > /dev/null; then
            echo -n "  $cmd - "
            $help_func
        else
            echo "  $cmd"
        fi
    done
    echo
    echo "Additional commands:"
    echo "  prompt \"<text>\" [engine]   Send prompt to engine (gpt4all, ollama, openai)"
    echo "  omnieye-module              Run the Omnieye subsystem"
    echo "  logs                       Tail last 50 log entries"
    echo "  version                    Show module versions"
    echo "  test-module <mod>          Run tests for module"
    echo "  help                       Show this help message"
    echo
}

show_versions() {
    echo "Omniscient Framework Modules Versions:"
    for cmd in "${!MODULES[@]}"; do
        # try to print MOD_VERSION if set
        mod_version_var="MOD_VERSION"
        # We rely on modules sourced already, so MOD_VERSION should be set per module
        # We prefix variable by mod_name to avoid conflicts
        version_var_name="MOD_VERSION_${cmd}"
        # fallback to generic MOD_VERSION if unique version vars aren't used
        version="${MOD_VERSION:-unknown}"

        # Check if module defines its own MOD_VERSION variable prefixed by module name
        version="$(eval echo \${MOD_VERSION_${cmd}:-$version})"
        echo "  $cmd : $version"
    done
}

run_module_test() {
    local mod="$1"
    local test_func="mod_${mod}_test"

    if [[ -z "$mod" ]]; then
        echo "[✘] Specify a module to test"
        return 1
    fi

    if ! declare -f "$test_func" > /dev/null; then
        echo "[!] No tests defined for module '$mod'"
        return 1
    fi

    echo "[*] Running tests for module '$mod'..."
    $test_func
}

# --------------------------
# Argument parsing
# --------------------------

if [[ -z "$1" ]]; then
    set -- help
fi

case "$1" in
    help)
        show_help
        exit 0
        ;;

    version)
        show_versions
        exit 0
        ;;

    test-module)
        shift
        run_module_test "$1"
        exit $?
        ;;

    prompt)
        prompt_text="$2"
        engine="${3:-$MODEL}"

        if [[ -z "$prompt_text" ]]; then
            echo "[✘] Please provide prompt text."
            exit 1
        fi

        if [[ "$engine" == "ollama" ]]; then
            response=$(curl -s -X POST "$OLLAMA_API" \
                -H "Content-Type: application/json" \
                -d "{\"model\": \"$MODEL\", \"prompt\": \"$prompt_text\"}")
            echo -e "\033[1;32mAI (Ollama):\033[0m $(echo "$response" | jq -r '.response // .result')"
        elif [[ "$engine" == "openai" ]]; then
            python3 -c "
import os, sys, openai
openai.api_key = os.getenv('OPENAI_API_KEY')
try:
    completion = openai.ChatCompletion.create(
        model='$MODEL',
        messages=[{'role': 'user', 'content': '$prompt_text'}]
    )
    print('\033[1;32mAI (OpenAI):\033[0m ' + completion.choices[0].message.content.strip())
except Exception as e:
    print('[✘] OpenAI request failed:', e)
"
        else
            # default or gpt4all or any other model, just run python script or binary
            python3 -c "
import sys
print(f'AI ({engine}): {prompt_text}')
# Placeholder for other engine integrations
"
        fi
        exit 0
        ;;

    omnieye-module)
        bash "$OMNIROOT/omnieye-blackbox/omnieye_module.sh"
        exit $?
        ;;

    logs)
        tail -n 50 "$LOG"
        exit 0
        ;;

    *)
        # Try to run module command if exists
        cmd="$1"
        if [[ -n "${MODULES[$cmd]}" ]]; then
            func="${MODULES[$cmd]}"
            shift
            $func "$@"
            exit $?
        else
            echo "[✘] Unknown command: $cmd"
            echo "Run 'omniscientctl help' for usage."
            exit 1
        fi
        ;;
esac

#!/bin/bash
# omniscientctl: Central management utility for Omniscient Framework

# Load environment variables
source /opt/omniscient/.autoenv/activate.sh

# Log file
LOGFILE="$PROMPT_LOG"

# Function: Log actions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$LOGFILE"
}

# Function: Display menu
show_menu() {
  echo "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Show system status"
  echo "6) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) show_status;;
    6) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

# Function: View core Omniscient environment variables
view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

# Function: Run AI summary process (mock/demo)
run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "Summary written to: $SUMMARY_LOG"
  echo "" >> "$SUMMARY_LOG"
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

# Function: Trigger maintenance job manually
trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

# Function: Start core services
start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

# Function: Show system status
show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"
  df -h | grep -E '/$|/opt|/var'
  echo "Memory:"
  free -h | grep -v Swap
  show_menu
}

# Entry point
clear
show_menu


#!/bin/bash
# omniscientctl - Omniscient system control CLI
# Location: /usr/local/bin/omniscientctl
# Description: Unified command entrypoint for framework, modules, dashboards, agents

OMNI_HOME="/opt/omniscient"
LOG="$OMNI_HOME/logs/omniscientctl.log"
MANIFEST="$OMNI_HOME/omniscient_manifest.csv"

log() {
  echo "[omniscientctl] $1" | tee -a "$LOG"
}

case "$1" in
  install|install-all)
    log "Running install hooks..."
    find "$OMNI_HOME" -name install.sh -exec bash {} \;
    ;;
  init|init-all)
    log "Running init hooks..."
    find "$OMNI_HOME" -name init.sh -exec bash {} \;
    ;;
  install-scan)
    log "Scanning directories for install/init scripts..."
    echo "Module,Init Found,Install Found" > "$OMNI_HOME/logs/install_scan_report.csv"
    for d in $(find "$OMNI_HOME" -mindepth 1 -maxdepth 3 -type d); do
      init="❌"
      install="❌"
      [[ -f "$d/init.sh" ]] && init="✅"
      [[ -f "$d/install.sh" ]] && install="✅"
      echo "$(basename "$d"),$init,$install" >> "$OMNI_HOME/logs/install_scan_report.csv"
    done
    log "Install scan complete. Report: $OMNI_HOME/logs/install_scan_report.csv"
    ;;
  script|script-scan)
    log "Checking for logging wrappers..."
    bash "$OMNI_HOME/init/inject_logging_wrapper.sh" --scan
    ;;
  manifest|manifest-rebuild)
    log "Rebuilding manifest..."
    echo "File,Category,Path,Checksum" > "$MANIFEST"
    find "$OMNI_HOME" -type f \( -name "*.sh" -o -name "*.py" \) | while read -r f; do
      base=$(basename "$f")
      cat=$(echo "$f" | grep -Eo '(ai|init|web|scripts|config|sql|bin|modules)' | head -n1)
      sum=$(md5sum "$f" | awk '{print $1}')
      echo "$base,$cat,$f,$sum" >> "$MANIFEST"
    done
    log "Manifest rebuilt at $MANIFEST"
    ;;
  dashboard|launch-dashboard)
    log "Launching unified dashboard..."
    streamlit run "$OMNI_HOME/web/unified_dashboard.py"
    ;;
  voice|voice-listen)
    log "Activating voice agent..."
    python3 "$OMNI_HOME/ai/voice_agent_upgraded.py"
    ;;
  help|--help|-h|"")
    echo "Omniscient System CLI"
    echo "Usage:"
    echo "  omniscientctl install-scan     # Scan modules for init/install"
    echo "  omniscientctl init-all         # Run all init.sh"
    echo "  omniscientctl install-all      # Run all install.sh"
    echo "  omniscientctl manifest-rebuild # Rebuild file manifest"
    echo "  omniscientctl script-scan      # Check/add logging to all scripts"
    echo "  omniscientctl launch-dashboard # Launch unified dashboard"
    echo "  omniscientctl voice-listen     # Activate voice agent"
    ;;
  *)
    echo "[!] Unknown command: $1"
    ;;
esac


#!/bin/bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Auto-source the environment
[ -f /opt/omniscient/.env ] && source /opt/omniscient/.env

OMNIROOT="/opt/omniscient"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $@" >> "$LOG"

# Load config values with crudini if available
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
    MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
    LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
    OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
    OPENAI_API_KEY=$(crudini --get "$CONF" openai API_KEY 2>/dev/null || echo "")
else
    MODEL="gpt4all"
    LOG_LEVEL="INFO"
    OLLAMA_API="http://localhost:11434/api/generate"
    OPENAI_API_KEY=""
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
    for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# Default to help if no arguments
[[ -z "$1" ]] && set -- "help"

case "$1" in
    "omnieye-module")
        bash "$OMNIROOT/omnieye-blackbox/omnieye_module.sh" || echo "[!] Failed to run omnieye-module" >> "$LOG"
        ;;

    "prompt")
        prompt="$2"
        engine=${3:-$MODEL}

        case "$engine" in
            "ollama")
                response=$(curl -s -X POST "$OLLAMA_API" \
                    -H "Content-Type: application/json" \
                    -d "{\"model\": \"$MODEL\", \"prompt\": \"$prompt\"}")
                echo -e "\033[1;32mAI (Ollama):\033[0m $(echo "$response" | jq -r '.response // .result')"
                ;;

            "openai")
                if [[ -z "$OPENAI_API_KEY" ]]; then
                    echo "[!] Missing OpenAI API key in config." | tee -a "$LOG"
                    exit 1
                fi
                python3 -c "
import os, openai
openai.api_key = '$OPENAI_API_KEY'
response = openai.ChatCompletion.create(
    model='gpt-4',
    messages=[{'role': 'user', 'content': '$prompt'}]
)
print('\033[1;34mAI (OpenAI):\033[0m', response['choices'][0]['message']['content'])
" || echo "[!] OpenAI API call failed" >> "$LOG"
                ;;

            "gpt4all")
                python3 -c "
from pathlib import Path
from dotenv import load_dotenv
load_dotenv('$OMNIROOT/.env')
from gpt4all import GPT4All
model = GPT4All(model_name='$MODEL')
with model:
    output = model.generate(prompt='$prompt', temp=0.7)
    print('\033[1;36mAI (GPT4All):\033[0m', output)
" || echo "[!] GPT4All execution failed" >> "$LOG"
                ;;

            *)
                echo "[!] Unknown engine: $engine" | tee -a "$LOG"
                ;;
        esac
        ;;

    "logs")
        tail -n 50 "$LOG"
        ;;

    "help")
        echo -e "\nOmniscient CLI Usage:\n"
        echo "  omniscientctl prompt \"<prompt text>\" [engine]   Send prompt to selected engine (gpt4all, ollama, openai)"
        echo "  omniscientctl omnieye-module                     Run the Omnieye subsystem"
        echo "  omniscientctl logs                                Tail the last 50 log entries"
        echo "  omniscientctl help                                Show this help message"
        ;;

    *)
        echo "[!] Unknown command: $1" | tee -a "$LOG"
        exec "$0" help
        ;;
esac






\_omniscientctl_completions()
{
  local cmds="prompt omnieye-module logs help"
  local engines="gpt4all openai ollama lmstudio"
  COMPREPLY=()

  case "${COMP_CWORD}" in
    1)
      COMPREPLY=( $(compgen -W "$cmds" -- "${COMP_WORDS[1]}") )
      ;;
    2)
      if [[ "${COMP_WORDS[1]}" == "prompt" ]]; then
        COMPREPLY=( $(compgen -W "\"<prompt here>\"" -- "${COMP_WORDS[2]}") )
      fi
      ;;
    3)
      if [[ "${COMP_WORDS[1]}" == "prompt" ]]; then
        COMPREPLY=( $(compgen -W "$engines" -- "${COMP_WORDS[3]}") )
      fi
      ;;
  esac
}

complete -F _omniscientctl_completions omniscientctl




create_module() {
    local mod_name="$1"
    local mod_dir="$OMNIROOT/modules"
    local mod_file="$mod_dir/mod_${mod_name}.sh"

    if [[ -z "$mod_name" ]]; then
        echo "[✘] Please specify a module name."
        return 1
    fi

    if [[ ! -d "$mod_dir" ]]; then
        mkdir -p "$mod_dir"
    fi

    if [[ -f "$mod_file" ]]; then
        echo "[✘] Module '$mod_name' already exists at $mod_file"
        return 1
    fi

    cat > "$mod_file" << EOF
#!/bin/bash

mod_${mod_name}() {
    echo "Module '$mod_name' loaded!"
    # TODO: Add your module logic here
}

EOF

    chmod +x "$mod_file"
    echo "[✔] Module '$mod_name' created at $mod_file"
    echo "Add 'mod_${mod_name}' to your omniscientctl case statement to enable it."
}



[core]
OMNISCIENT_ROOT=/opt/omniscient
LOG_LEVEL=INFO
SUMMARY_LOG=/opt/omniscient/logs/ai_summary.log
PROMPT_LOG=/opt/omniscient/logs/omniscientctl.log
PERIODIC_MAINTENANCE=/opt/omniscient/scripts/maintenance.sh

[models]
MODEL_BACKEND=gpt4all
OLLAMA_API=http://localhost:11434/api/generate

[services]
SERVICES_TO_ENABLE=apache2,mariadb,ssh

[directories]
MODULE_DIR=/opt/omniscient/modules
PLUGIN_DIR=/opt/omniscient/plugins
SCRIPT_DIRS=ai,core,bin,menus,modules,malformed,offensive,system,scripts,osint,logs

[network]
IP_ADDRESS=192.168.1.74
GATEWAY=192.168.1.1
DNS_SERVERS=1.1.1.1 8.8.4.4

[version]
CLI_VERSION=1.0.0


#!/bin/bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Auto-source the environment
[ -f /opt/omniscient/.env ] && source /opt/omniscient/.env
source /opt/omniscient/.autoenv/activate.sh


OMNIROOT="/opt/omniscient"
SCRIPT_DIRS=("ai" "core" "bin" "menus" "modules" "malformed" "offensive" "system" "scripts" "osint" "logs")


OMNIDIR="/opt/omniscient/control/omniscientctl.d"

# Load drop-ins
for f in "$OMNIDIR"/*.bash; do
    [[ -f "$f" ]] && source "$f"
done

# Dispatcher
case "$1" in
    ai|ai-pipe) cmd_ai_pipe "${@:2}" ;;
    backup|backupctl) cmd_backupctl "${@:2}" ;;
    *) echo "Unknown command: $1"; exit 1 ;;
esac



OMNIROOT="/opt/omniscient"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"


browse_directories() {
  echo -e "\n📂 Available Script Categories:"
  select dir in "${SCRIPT_DIRS[@]}" "Back"; do
    if [[ "$dir" == "Back" ]]; then
      show_menu
      return
    fi

    TARGET="$OMNIROOT/$dir"
    if [[ -d "$TARGET" ]]; then
      echo -e "\n📁 $dir Directory Contents:"
      files=("$TARGET"/*.sh "$TARGET"/*.bash)
      select file in "${files[@]}" "Back"; do
        if [[ "$file" == "Back" ]]; then
          browse_directories
          return
        elif [[ -f "$file" ]]; then
          echo -e "\n🚀 Executing: $file\n"
          log_action "Executing user script: $file"
          bash "$file"
          break
        else
          echo "Invalid selection. Try again."
        fi
      done
    else
      echo "[✘] Directory not found: $TARGET"
    fi
    break
  done
}


show_menu() {
  echo -e "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Restart core services"
  echo "6) Stop core services"
  echo "7) Check service health"
  echo "8) Show system status"
  echo "9) Run plugins"
  echo "10) Explore script directories"
  echo "11) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) restart_services;;
    6) stop_services;;
    7) health_check;;
    8) show_status;;
    9) run_plugins;;
    10) browse_directories;;
    11) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}



# Load config values with crudini if available
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
    MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
    LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
    OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
    MODEL="gpt4all"
    LOG_LEVEL="INFO"
    OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
    for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# --------------------------
# Module auto-registration
# --------------------------
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
    for mod_file in "$MODULE_DIR"/mod_*.sh; do
        [[ -f "$mod_file" ]] || continue
        mod_basename=$(basename "$mod_file" .sh)
        mod_name=${mod_basename#mod_}

        # Check if module enabled in config (default true)
        enabled="true"
        if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
            enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
        fi

        if [[ "$enabled" == "true" ]]; then
            source "$mod_file"
            MODULES["$mod_name"]="mod_${mod_name}"
        fi
    done
fi

# --------------------------
# Helper functions
# --------------------------

log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$PROMPT_LOG"
}

# --------------------------
# Rsyslog command wrappers
# --------------------------

rsyslog_start() {
  sudo systemctl start rsyslog
  echo "rsyslog service started."
}

rsyslog_stop() {
  sudo systemctl stop rsyslog
  echo "rsyslog service stopped."
}

rsyslog_restart() {
  sudo systemctl restart rsyslog
  echo "rsyslog service restarted."
}

rsyslog_status() {
  sudo systemctl status rsyslog
}

rsyslog_reload() {
  sudo systemctl reload rsyslog
  echo "rsyslog service reloaded."
}

show_help() {
    echo -e "\nOmniscient CLI Usage:\n"
    echo "  omniscientctl <command> [args...]"
    echo
    echo "Available commands from modules:"
    for cmd in "${!MODULES[@]}"; do
        help_func="mod_${cmd}_help"
        if declare -f "$help_func" > /dev/null; then
            echo -n "  $cmd - "
            $help_func
        else
            echo "  $cmd"
        fi
    done
    echo
    echo "Additional commands:"
    echo "  prompt \"<text>\" [engine]   Send prompt to engine (gpt4all, ollama, openai)"
    echo "  omnieye-module              Run the Omnieye subsystem"
    echo "  logs                       Tail last 50 log entries"
    echo "  version                    Show module versions"
    echo "  test-module <mod>          Run tests for module"
    echo "  help                       Show this help message"
    echo
}

show_versions() {
    echo "Omniscient Framework Modules Versions:"
    for cmd in "${!MODULES[@]}"; do
        # try to print MOD_VERSION if set
        mod_version_var="MOD_VERSION"
        # We rely on modules sourced already, so MOD_VERSION should be set per module
        # We prefix variable by mod_name to avoid conflicts
        version_var_name="MOD_VERSION_${cmd}"
        # fallback to generic MOD_VERSION if unique version vars aren't used
        version="${MOD_VERSION:-unknown}"

        # Check if module defines its own MOD_VERSION variable prefixed by module name
        version="$(eval echo \${MOD_VERSION_${cmd}:-$version})"
        echo "  $cmd : $version"
    done
}

run_module_test() {
    local mod="$1"
    local test_func="mod_${mod}_test"

    if [[ -z "$mod" ]]; then
        echo "[✘] Specify a module to test"
        return 1
    fi

    if ! declare -f "$test_func" > /dev/null; then
        echo "[!] No tests defined for module '$mod'"
        return 1
    fi

    echo "[*] Running tests for module '$mod'..."
    $test_func
}

# --------------------------
# Interactive Menu Functions
# --------------------------

() {
  echo -e "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Show system status"
  echo "6) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) show_status;;
    6) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "Summary written to: $SUMMARY_LOG"
  echo "" >> "$SUMMARY_LOG"
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echshow_menuo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"
  df -h | grep -E '/$|/opt|/var'
  echo "Memory:"
  free -h | grep -v Swap
  show_menu
}

# --------------------------
# CLI Entry Point
# --------------------------

if [[ -z "$1" ]]; then
    clear
    show_menu
    exit 0
fi

case "$1" in
    help)
        show_help
        exit 0
        ;;
    version)
        show_versions
        exit 0
        ;;
    test-module)
        shift
        run_module_test "$1"
        exit $?
        ;;
    prompt)
        prompt_text="$2"
        engine="${3:-$MODEL}"

        if [[ -z "$prompt_text" ]]; then
            echo "[✘] Please provide prompt text."
            exit 1
        fi

        if [[ "$engine" == "ollama" ]]; then
            response=$(curl -s -X POST "$OLLAMA_API" \
                -H "Content-Type: application/json" \
                -d "{\"model\": \"$MODEL\", \"prompt\": \"$prompt_text\"}")
            echo -e "\033[1;32mAI (Ollama):\033[0m $(echo "$response" | jq -r '.response // .result')"
        elif [[ "$engine" == "openai" ]]; then
            python3 -c "
import os, sys, openai
openai.api_key = os.getenv('OPENAI_API_KEY')
try:
    completion = openai.ChatCompletion.create(
        model='$MODEL',
        messages=[{'role': 'user', 'content': '$prompt_text'}]
    )
    print('\033[1;32mAI (OpenAI):\033[0m ' + completion.choices[0].message.content.strip())
except Exception as e:
    print('[✘] OpenAI request failed:', e)
"
        else
            # default or gpt4all or any other model, just run python script or binary
            python3 -c "
import sys
print(f'AI ({engine}): {prompt_text}')
# Placeholder for other engine integrations
"
        fi
        exit 0
        ;;
    omnieye-module)
        bash "$OMNIROOT/omnieye-blackbox/omnieye_module.sh"
        exit $?
        ;;
    logs)
        tail -n 50 "$LOG"
        exit 0
        ;;
    rsyslog)
        shift
        case "$1" in
            start)
                rsyslog_start
                ;;
            stop)
                rsyslog_stop
                ;;
            restart)
                rsyslog_restart
                ;;
            status)
                rsyslog_status
                ;;
            reload)
                rsyslog_reload
                ;;
            *)
                echo "Usage: omniscientctl rsyslog {start|stop|restart|status|reload}"
                exit 1
                ;;
        esac
        exit 0
        ;;
    *)
        # Try to run module command if exists
        cmd="$1"
        if [[ -n "${MODULES[$cmd]}" ]]; then
            func="${MODULES[$cmd]}"
            shift
            $func "$@"
            exit $?
        else
            echo "[✘] Unknown command: $cmd"
            echo "Run 'omniscientctl help' for usage."
            exit 1
        fi
        ;;
esac


#!/bin/bash

# Set global variables
OMNISCIENT_DIR="/opt/omniscient"
VENV_DIR="$OMNISCIENT_DIR/venv"
LOGFILE="$OMNISCIENT_DIR/logs/omniscientctl.log"

# Activate virtual environment silently
source "$VENV_DIR/bin/activate" 2>/dev/null

# Log function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOGFILE"
}

# Run a command with logging
run_cmd() {
    log "$1"
    shift
    "$@"
}

# Navigate to a directory and run a command
launch_gui() {
    local dir="$1"
    local cmd="$2"
    if cd "$dir" 2>/dev/null; then
        run_cmd "Launching interface in $dir..." $cmd
    else
        log "Directory $dir not found. Exiting."
        exit 1
    fi
}

# Execute a script file with logging
exec_script() {
    local script="$1"
    if [[ -x "$script" || -f "$script" ]]; then
        run_cmd "Executing $script..." bash "$script"
    else
        log "Script $script not found or not executable."
        exit 1
    fi
}

# Command handler
case "$1" in
    start)
        run_cmd "Starting Omniscient service..." systemctl start omniscient.service
        ;;
    stop)
        run_cmd "Stopping Omniscient service..." systemctl stop omniscient.service
        ;;
    restart)
        run_cmd "Restarting Omniscient service..." systemctl restart omniscient.service
        ;;
    status)
        systemctl status omniscient.service
        ;;
    gui)
        launch_gui "$OMNISCIENT_DIR/web" "python3 app.py"
        ;;
    streamlit)
        launch_gui "$OMNISCIENT_DIR/web" "streamlit run dashboard.py"
        ;;
    logs)
        run_cmd "Opening Omniscient logs..." less "$LOGFILE"
        ;;
    update)
        run_cmd "Updating Omniscient framework..." git -C "$OMNISCIENT_DIR" pull
        exec_script "$OMNISCIENT_DIR/init/setup_omniscient.sh"
        ;;
    install)
        exec_script "$OMNISCIENT_DIR/init/setup_omniscient.sh"
        ;;
    shell)
        run_cmd "Launching interactive AI shell..." python3 "$OMNISCIENT_DIR/ai/interactive_shell.py"
        ;;
    backup)
        exec_script "$OMNISCIENT_DIR/scripts/backup.sh"
        ;;
    help|-h|--help)
        cat <<EOF

Omniscient Framework Control Utility

Usage:
  omniscientctl <command>

Commands:
  start         Start Omniscient service
  stop          Stop Omniscient service
  restart       Restart Omniscient service
  status        Show service status
  gui           Launch Flask interface
  streamlit     Launch Streamlit dashboard
  logs          View omniscientctl log
  update        Pull latest Omniscient updates and run setup
  install       Run Omniscient system installer
  shell         Launch AI-powered local shell
  backup        Run backup routine
  help          Show this help message

EOF
        ;;
    *)
        echo "Invalid command: '$1'"
        echo "Use 'omniscientctl help' for a list of available commands."
        exit 1
        ;;
esac


#!/bin/bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Version
OMNISCIENTCTL_VERSION="1.0.0"

# Auto-source environment
OMNIROOT="/opt/omniscient"
[ -f "$OMNIROOT/.env" ] && source "$OMNIROOT/.env"
source "$OMNIROOT/.autoenv/activate.sh"

SCRIPT_DIRS=("ai" "core" "bin" "menus" "modules" "malformed" "offensive" "system" "scripts" "osint" "logs")
OMNIDIR="$OMNIROOT/control/omniscientctl.d"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
PROMPT_LOG="${PROMPT_LOG:-$OMNIROOT/logs/prompt.log}"

mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"

# Load drop-in shell modules
for f in "$OMNIDIR"/*.bash; do [[ -f "$f" ]] && source "$f"; done

# Helper Functions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$PROMPT_LOG"
}

restart_services() {
  log_action "Restarting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Restarting $service..."
    sudo systemctl restart "$service"
  done
  show_menu
}

stop_services() {
  log_action "Stopping core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Stopping $service..."
    sudo systemctl stop "$service"
  done
  show_menu
}

health_check() {
  log_action "Checking health of core services"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    STATUS=$(systemctl is-active "$service")
    echo "$service → $STATUS"
  done
  show_menu
}

run_plugins() {
  local plugin_dir="${OMNISCIENT_PLUGIN_DIR:-$OMNIROOT/plugins}"
  echo -e "\n🗉 Executing plugins in $plugin_dir"
  for plugin in "$plugin_dir"/*.sh; do
    [ -x "$plugin" ] && echo "→ Running $(basename "$plugin")" && bash "$plugin"
  done
  show_menu
}

browse_directories() {
  echo -e "\n📂 Available Script Categories:"
  select dir in "${SCRIPT_DIRS[@]}" "Back"; do
    [[ "$REPLY" == $(( ${#SCRIPT_DIRS[@]} + 1 )) ]] && show_menu && return
    TARGET="$OMNIROOT/$dir"
    if [[ -d "$TARGET" ]]; then
      echo -e "\n📁 $dir Directory Contents:"
      mapfile -t files < <(find "$TARGET" -maxdepth 1 -type f \( -name "*.sh" -o -name "*.bash" \))
      select file in "${files[@]}" "Back"; do
        [[ "$REPLY" == $(( ${#files[@]} + 1 )) ]] && browse_directories && return
        if [[ -f "$file" ]]; then
          echo -e "\n📄 Previewing script: $file"
          log_action "Previewing user script: $file"
          head -n 50 "$file" | nl
          echo -e "\n[?] Execute this script? (y/n): "
          read -r exec_choice
          if [[ "$exec_choice" =~ ^[Yy]$ ]]; then
            bash "$file"
          else
            echo "Skipped execution."
          fi
        else
          echo "Invalid selection. Try again."
        fi
        break
      done
    else
      echo "[\u2718] Directory not found: $TARGET"
    fi
    break
  done
}

# Load config values
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
  MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
  LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
  OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
  MODEL="gpt4all"; LOG_LEVEL="INFO"; OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
  for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
    [[ -f "$path" ]] && source "$path" && break
  done
fi

# Auto-register modules
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
  for mod_file in "$MODULE_DIR"/mod_*.sh; do
    [[ -f "$mod_file" ]] || continue
    mod_basename=$(basename "$mod_file" .sh)
    mod_name=${mod_basename#mod_}
    enabled="true"
    if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
      enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
    fi
    if [[ "$enabled" == "true" ]]; then
      source "$mod_file"
      MODULES["$mod_name"]="mod_${mod_name}"
    fi
  done
fi

# Menu Functions
show_menu() {
  echo -e "\n🧠 Omniscient Control Panel"
  echo "──────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Restart core services"
  echo "6) Stop core services"
  echo "7) Check service health"
  echo "8) Show system status"
  echo "9) Run plugins"
  echo "10) Explore script directories"
  echo "11) Show version info"
  echo "12) Exit"
  echo "──────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) restart_services;;
    6) stop_services;;
    7) health_check;;
    8) show_status;;
    9) run_plugins;;
    10) browse_directories;;
    11) show_versions;;
    12) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

show_versions() {
  echo "\n🧐 OmniscientCTL Version: $OMNISCIENTCTL_VERSION"
  if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null; then
    branch=$(git rev-parse --abbrev-ref HEAD)
    commit=$(git rev-parse --short HEAD)
    echo "🔖 Git: Branch [$branch], Commit [$commit]"
  fi
  echo "📂 Framework Modules:"
  for cmd in "${!MODULES[@]}"; do
    version_var="MOD_VERSION_${cmd}"
    version="${!version_var:-${MOD_VERSION:-unknown}}"
    echo "  $cmd : $version"
  done
  show_menu
}

# Placeholder function stubs for completeness
view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"; df -h | grep -E '/$|/opt|/var'
  echo "Memory:"; free -h | grep -v Swap
  show_menu
}

# CLI Entry Point
if [[ -z "$1" ]]; then
  clear
  show_menu
  exit 0
fi

case "$1" in
  version|--version|-v) show_versions; exit 0 ;;
  *) echo "[✘] Unknown command: $1"; show_menu; exit 1 ;;
esac


https://chatgpt.com/c/68810534-113c-8004-b54e-f14c8c603111



ollama run mistral-small

sudo systemctl restart rsyslog

# Clean APT cache (safe and effective)
sudo apt clean && sudo apt autoclean


# Remove old journal logs (keep only last 2 days)
sudo journalctl --vacuum-time=2d


# Remove orphaned packages
sudo apt autoremove --purge -y


# Truncate all system logs in /var/log (without deleting files)
sudo find /var/log -type f -exec truncate -s 0 {} \;


# Empty user trash
rm -rf ~/.local/share/Trash/* ~/.Trash/*


# Find and list files >500MB (review before deleting)
find / -type f -size +500M -exec ls -lh {} \; 2>/dev/null | sort -k5 -rh | head -n 20


# Delete core dumps (if any exist)
sudo find / -type f -name 'core' -delete 2>/dev/null


# Remove old Snap revisions
sudo snap list --all | awk '/disabled/{print $1, $3}' | while read snapname revision; do sudo snap remove "$snapname" --revision="$revision"; done


# Remove Flatpak unused runtimes (if using Flatpak)
flatpak uninstall --unused -y


# Remove user-level cache (reclaim hundreds of MBs safely)
rm -rf ~/.cache/*


# Find top 20 biggest directories (helpful to decide where to clean)
sudo du -ahx / | sort -rh | head -n 20



# Find duplicate files over 100MB (smart cleanup)
fdupes -rSm / | awk '$1 > 104857600' | head -n 20






find / -type d \( -iname "*backups*" -o -iname "*archives*" \) 2>/dev/null | tee /tmp/deletion_index_$(date '+%Y-%m-%d_%H-%M-%S').log | while read dir; do echo "Indexing: $dir" >> /tmp/deletion_index_full.log && find "$dir" -type f >> /tmp/deletion_index_full.log && sudo rm -rf "$dir"; done


find / -type d \( -iname "*backups*" -o -iname "*archives*" \) 2>/dev/null | tee /tmp/would_delete_$(date '+%Y-%m-%d_%H-%M-%S').log | while read dir; do echo "Would index and delete: $dir"; find "$dir" -type f >> /tmp/would_delete_index.log; done



find / -type d -empty 2>/dev/null | tee /tmp/empty_dirs_found_$(date '+%Y-%m-%d_%H-%M-%S').log



find / -type d -empty 2>/dev/null | tee /tmp/empty_dirs_removed_$(date '+%Y-%m-%d_%H-%M-%S').log | xargs -I{} rm -rf "{}"



find /home /opt /var -type d -empty 2>/dev/null | tee ~/logs/empties.log | xargs rm -rf




find /path/to/scan -type f -printf '%A@ %T@ %p\n' 2>/dev/null | awk '{printf "Accessed: %d days ago\tModified: %d days ago\t%s\n", (systime()-$1)/86400, (systime()-$2)/86400, $3}'

find /path/to/scan -type d -printf '%A@ %T@ %p\n' 2>/dev/null | awk '{printf "Accessed: %d days ago\tModified: %d days ago\t%s\n", (systime()-$1)/86400, (systime()-$2)/86400, $3}'



find /path/to/scan -type f -ctime -7 -exec ls -lh --time=creation {} + 2>/dev/null



ausearch -x rm | grep -i 'name='




auditctl -a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -k file_deletion





inotifywait -m -r -e create -e delete -e modify --format '%T %e %w%f' --timefmt '%F %T' /path/to/watch



find / -type f -printf '%T+ %p\n' 2>/dev/null | sort -r | head -n 50


find / -type d -printf '%A@ %p\n' 2>/dev/null | sort -nr | head -n 30 | awk '{printf "Accessed %d days ago\t%s\n", (systime()-$1)/86400, $2}'



find / -type f -ctime -1 -exec ls -lh {} \; 2>/dev/null | sort -k6,7




du -h / --max-depth=3 2>/dev/null | sort -hr | head -n 30



find / -type f -perm -002 -ls 2>/dev/null



find / -type f -mmin -60 -exec ls -lh {} \; 2>/dev/null



find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \; 2>/dev/null



find / -type l -exec ls -lah {} \; 2>/dev/null | grep "->"



lsof | grep deleted



find / -type f -name ".*" -o -name "* *" -o -name "*..*" 2>/dev/null



find / -type f -exec sha256sum {} \; 2>/dev/null | sort > /tmp/full_hash_index.txt


sudo lsof -nPi | grep LISTEN



find / -type f -perm /111 -mtime -7 -exec ls -lh {} \; 2>/dev/null



grep -vE '/false|/nologin' /etc/passwd | awk -F: '{print $1, $7}'




last -a | head -n 20



find /opt/omniscient -type f \( -iname "*.sh" -o -iname "*.py" \) -exec head -n 1 {} \; | nl > /opt/omniscient/logs/command_manifest.log


find /opt/omniscient -type f -perm /111 -exec ls -lh --time-style=long-iso {} \; | sort -k6,7


find /opt/omniscient -type f -exec sha256sum {} \; | sort > /opt/omniscient/logs/sha256_manifest.txt



grep -rnE '^\s*(function\s+\w+|\w+\s*\(\))' /opt/omniscient > /opt/omniscient/logs/function_index.log



find /opt/omniscient -type f ! -perm /111 -mtime +30 -exec ls -lh {} \; > /opt/omniscient/logs/autopsy_dormant_scripts.log



grep -rlE "(echo|cat|printf|sed|tee).*(>>|>).*\.sh" /opt/omniscient



grep -riE "(ollama|gpt|openai|huggingface|endpoint|prompt|model)" /opt/omniscient



grep -rilE 'if|case|else|match|prompt' /opt/omniscient | xargs grep -E "decision|prompt|response|select"



find /opt/omniscient \( -name "*.pyc" -o -name "*.o" -o -name "__pycache__" \) -exec rm -rf {} +


find /opt/omniscient/logs -type f -mtime +14 -exec rm -f {} \;



grep -roE "(http|https|ssh)://[a-zA-Z0-9./?=_%:-]*" /opt/omniscient | sort -u


find /opt/omniscient -type f -name "*.sh" ! -perm /111 | grep -vFf <(grep -oP 'omniscientctl\s+\K\w+' /opt/omniscient/omniscientctl)


grep -rEi 'token|secret|api[_-]?key|passwd' /opt/omniscient/*.{conf,json,env} 2>/dev/null



mount -o remount,ro /


tar czf /media/usb/omniscient_logs_$(date +%F).tgz /opt/omniscient/logs


ollama run llama3 "What is the difference between TCP and UDP?"

prompt="Summarize the contents of /var/log/syslog"; ollama run llama3 "$prompt"


prompt="Summarize the contents of /var/log/syslog"; ollama run llama3 "$prompt"


cat README.md | ollama run llama3


tail -n 200 /var/log/syslog | ollama run llama3


find . -name "*.py" -exec cat {} \; | ollama run llama3


cat suspicious.sh | ollama run code-llama:latest







find . -name "*.py" -exec cat {} \; | ollama run llama3



cat suspicious.sh | ollama run code-llama:latest


diff -u file1.py file2.py | ollama run llama3



tar czf - ./omniscient | base64 | ollama run llama3



grep -i "api_key" *.py | ollama run llama3



find / -type f -name "*.sh" -mtime -1 -exec ls -lh {} \; 2>/dev/null | ollama run llama3



du -ah /opt/omniscient | sort -hr | head -n 30 | ollama run llama3



ps aux --sort=-%mem | head -n 20 | ollama run llama3



grep " install " /var/log/apt/history.log | tail -n 10 | ollama run llama3





find / -type f -mtime -7 -exec ls -lh {} \; 2>/dev/null | ollama run llama3


find /opt/omniscient -type f \( -name "*.sh" -o -name "*.py" \) -exec cat {} \; | ollama run llama3 "Label and categorize these scripts by purpose and tags:"


cat domains.txt | ollama run llama3 "Highlight any suspicious, malicious, or known phishing domains from this list:"



cat *.md | ollama run llama3 "Generate a CLI usage cheatsheet based on this documentation:"



while sleep 60; do tail -n 100 /var/log/syslog | ollama run llama3 "Summarize any errors or warnings in the past 60 seconds"; done


cat $(find /opt/omniscient -type f -name "*.sh") | ollama run llama3 "Summarize this multi-script toolkit and outline the full workflow."



tar -czf - /etc | ollama run llama3 "Scan these config files for insecure defaults, exposed services, or poor hardening."



diff -u old_version.py new_version.py | ollama run llama3 "Generate a changelog summary for these code differences."


./my_tool --help | ollama run llama3 "What does this CLI tool do based on the help output?"



grep '^alias' ~/.bashrc ~/.zshrc 2>/dev/null | ollama run llama3 "Explain the function of each alias and suggest improvements."



(lsof -i -nP; ps aux --sort=-%mem) | ollama run llama3 "Identify suspicious behavior, high-risk processes, or unexpected connections."



(du -sh /opt/omniscient; find /opt/omniscient -type f | wc -l; find /opt/omniscient -type f | xargs file | head -n 50) | ollama run llama3 "Summarize and profile the contents and purpose of this directory."



cat script.py | ollama run code-llama "Refactor this Python code for performance, readability, and error handling."


cat *.md *.txt | ollama run llama3 "Ingest and retain this documentation for follow-up queries. Begin indexing."



ollama run llama3 "What does the documentation say about setting up VPN integration?"



watch -n 30 'journalctl -n 100 | ollama run llama3 "Diagnose errors or recurring issues in these logs."'


history | tail -n 2 | head -n 1 | ollama run llama3 "This command failed. Why? Suggest the correct syntax."



dpkg -l | grep -i 'http\|ssl\|crypto' | ollama run llama3 "Analyze these packages for known vulnerabilities or outdated libraries."



cat *.sh | ollama run llama3 "Find all the logging functions and grep-like matches for 'debug', 'warn', or 'info'."




cat ~/.bash_history | tail -n 100 | ollama run llama3 "Analyze my last 100 commands and suggest a shell alias pack to streamline my workflow."



find / -type f -size +500M -exec ls -lh {} \; 2>/dev/null | ollama run llama3 "Classify these large files: which are user data, logs, archives, or likely system files?"



diff -r dir1/ dir2/ | ollama run llama3 "Describe the key differences between these two folders at a high level."



sudo iptables -L -n -v | ollama run llama3 "Explain these iptables rules and suggest improvements for hardening."



for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l 2>/dev/null; done | ollama run llama3 "Explain what each cron job does and flag suspicious ones."



grep -iE "fail|error|unauth|panic|segfault" /var/log/* 2>/dev/null | ollama run llama3 "Highlight recurring error patterns or signs of intrusion."



cat credentials.txt | ollama run llama3 "Redact any secrets, passwords, API keys, or tokens. Return a clean version."



systemd-analyze blame | ollama run llama3 "Explain slow boot services and recommend optimizations."



find /opt/omniscient -type f \( -name "*.conf" -o -name "*.env" \) -exec cat {} \; | ollama run llama3 "Summarize configuration structure, services involved, and potential risks."


diff /etc/ssh/sshd_config.bak /etc/ssh/sshd_config | ollama run llama3 "Explain the impact and potential vulnerabilities of this change."



cat unknown_script.sh | ollama run llama3 "Reverse engineer and explain this script line-by-line. Is it malicious?"



cat yourscript.sh | ollama run llama3 "Create a markdown README with description, usage, options, and example output."



tail -n 1000 ~/.bash_history | ollama run llama3 "Suggest better alternatives, aliases, and shell functions based on my history."


diff <(du -ahx / | sort -hr | head -n 50) <(cat /tmp/yesterday_disk_snapshot.log) | ollama run llama3 "Explain what's grown or changed significantly in disk usage."



strings capture.pcap | head -n 500 | ollama run llama3 "Look for signs of malware, C2 traffic, or DNS tunneling."



( last -a; who; w ) | ollama run llama3 "Summarize system login behavior. Look for anomalies or unauthorized access."


declare -f myfunc | ollama run llama3 "Write a manpage for this Bash function with synopsis, options, and examples."


cat /var/log/apache2/access.log | tail -n 1000 | ollama run llama3 "Summarize unusual access patterns, HTTP errors, or brute force signs."


ip a | ollama run llama3 "Summarize my active network interfaces and their purposes."


cat ~/.bashrc | ollama run llama3 "Audit this bashrc for security holes, alias bloat, and environment variable risks. Optimize it."


mysqldump -d -u root -p yourdb | ollama run llama3 "Summarize this database schema and point out normalization or performance issues."


tree /opt/omniscient | ollama run llama3 "Describe the folder layout and infer what each directory is used for."


cat script.py | grep -A 20 "def" | ollama run llama3 "Write pytest test cases for the following Python functions."



(cat /var/log/syslog; cat /var/log/auth.log) | tail -n 500 | ollama run llama3 "What’s the most likely root cause of recurring errors across these logs?"


grep -rniE "token|key|secret|pass|authorization" /opt/omniscient | ollama run llama3 "Evaluate and redact any exposed secrets. Mark severity."


grep -iE "DROP|REJECT" /var/log/kern.log | tail -n 500 | ollama run llama3 "Summarize blocked traffic attempts and suspected attack types."


cat /var/log/clamav/clamav.log | ollama run llama3 "Identify any critical malware hits, classify severity, and provide threat intelligence."


cat /etc/ssh/sshd_config | ollama run llama3 "Review SSH config for best practices and highlight any insecure settings."


tail -n 100 /var/log/apache2/access.log | ollama run llama3 "Summarize the latest web requests. Highlight errors, suspicious paths, or DDoS patterns."


docker ps -a | ollama run llama3 "Assess these containers. Look for signs of unused, outdated, or risky services."



dpkg-query -l | ollama run llama3 "Highlight unnecessary, risky, or redundant packages."


for user in $(cut -f1 -d: /etc/passwd); do crontab -u $user -l 2>/dev/null; done | ollama run llama3 "Explain these cron jobs. Identify suspicious or obsolete entries."


cat /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null | ollama run llama3 "Summarize logging rules, retention policies, and custom filters."


cat /etc/nginx/sites-enabled/* 2>/dev/null | ollama run llama3 "Check these vhost configs for directory traversal risks, open ports, or weak SSL setup."


diff original.sh edited.sh | ollama run llama3 "What changed and why might this be significant?"


sudo iptables-save | ollama run llama3 "Break down these rules into readable firewall policies."


pip list --format=freeze | ollama run llama3 "Identify any packages with known vulnerabilities or out-of-date versions."


git log --pretty=format:"%h %s" | ollama run llama3 "Create a professional changelog based on these commits."


ausearch --start recent | ollama run llama3 "Highlight suspicious syscalls or policy violations."


grep 'sudo:' /var/log/auth.log | grep 'incorrect password' | ollama run llama3 "Summarize sudo authentication failures and possible brute force attempts."


tree /opt/omniscient | ollama run llama3 "Infer project structure and purpose of each directory."


cat ~/.bash_history ~/.zsh_history | ollama run llama3 "Generate secure and useful shell aliases based on my usage patterns."


find /opt/omniscient -type f -exec stat --format '%n %y' {} \; | sort | ollama run llama3 "Create a file change timeline from these timestamps."


find /opt/omniscient -type f -name "*.sh" | ollama run llama3 "For each script, generate a .desktop file with proper name, icon, and execution path."


top -b -n 1 | head -n 30 | ollama run llama3 "Explain high-resource processes and suggest optimizations."



cat /etc/passwd | ollama run llama3 "Identify system users, interactive users, and flag any suspicious accounts."


lshw -short | ollama run llama3 "Summarize this system’s hardware and rate it for performance, bottlenecks, or upgrade suggestions."


cat backup.sql | ollama run llama3 "Review this schema for normalization, performance, and indexing issues."


cat urls.txt | ollama run llama3 "Classify these URLs as safe, phishing, suspicious, or scam."


cat *.json | ollama run llama3 "Summarize key events, types, and metrics from these JSON logs."


my_tool --help | ollama run llama3 "Create a markdown-based help guide. Include usage, options, and examples." | pandoc -o help.pdf


my_tool --help | ollama run llama3 "Create a markdown-based help guide. Include usage, options, and examples." | pandoc -o help.pdf





fdupes -r /opt/omniscient /opt/sdb1 | tee /tmp/dupes.log | ollama run llama3 "This is a list of duplicate files. Analyze patterns in these duplicates. Why do they exist? What does this suggest about the project structure? Suggest how I should deduplicate or refactor the system to avoid this issue going forward."



fdupes -r /opt/omniscient /opt/sdb1 | tee /tmp/dupes.log | ollama run llama3 "This is a list of duplicate files. Analyze patterns in these duplicates. Why do they exist? What does this suggest about the project structure? Suggest how I should deduplicate or refactor the system to avoid this issue going forward."


fdupes -r -dN /opt/omniscient /opt/sdb1 | tee /tmp/dupes_deleted.log | ollama run llama3 "Here are files that were auto-deleted. Reflect on this action. What type of files were removed? Was this risky or safe?"



sudo du -h / --max-depth=2 2>/dev/null | sort -hr | head -n 30 | tee /tmp/disk_usage_top.log | ollama run llama3 "This is a snapshot of the top-level disk usage. Reflect on which directories consume the most space and why. What patterns do you notice about this system’s structure? Suggest actions to reclaim space or refactor directory layout to optimize long-term maintainability."


"Based on this disk usage, what does this tell you about how the system is used? Are there legacy files, logs, or duplicated structures?"

"Suggest cleanup steps for each directory over 1G. Which ones are likely log files, caches, or duplications?"

"Does this disk layout suggest a modular or monolithic system? What are the risks of this structure?"


tree /opt/omniscient | ollama run llama3 "Here is the directory structure of a system. Does this disk layout suggest a modular or monolithic architecture? Identify strengths, weaknesses, and potential risks in how this system is organized. Suggest improvements for scalability, maintainability, and security."

"Does this directory layout reflect a good separation of concerns? Are logic, AI, logging, configs, and interfaces appropriately separated?"

"Which directories might pose security risks? Are permissions, backups, or logs structured in a way that could expose data or cause failure?"

"Does this structure indicate accumulated technical debt? What refactoring would improve system clarity and maintenance velocity?"



read -p "Remove venv from: " i; find $i -type d \( -iname "venv" -o -iname ".venv" -o -iname "env" -o -iname ".env" \) 2>/dev/null | tee /tmp/venvs_found_$(date +%F).log | xargs -r sudo rm -rf

find /opt/omniscient/home/jeremy -type d \( -iname "venv" -o -iname ".venv" -o -iname "env" -o -iname ".env" \) 2>/dev/null | tee /tmp/venvs_removed_$(date +%F_%H-%M).log | xargs -r rm -rf


rsync -avh --progress --info=stats2 /opt/omniscient/archives/ /opt/sdb1/omniscient_archives/ | tee ~/logs/rsync_archives_$(date +%F_%H-%M).log && rm -rf /opt/omniscient/archives/


find /etc /opt /usr /var -type f -mtime -2 -not -path "*/.cache/*" 2>/dev/null | tee /tmp/recent_mods_$(date +%F_%H-%M).log | tee >(ollama run llama3 "These are recently modified system files. Identify what types of changes may have occurred. Suggest which should be backed up, investigated, or version controlled.") | tar -czf ~/backup_recent_mods_$(date +%F_%H-%M).tgz -T -





cat /var/log/syslog | tail -n 100 | ollama run llama3 "Summarize this cron activity. Highlight recurring jobs, failures, or anything unusual."



read -p "Describe the tools you want installed: " desc && echo "Write a robust, idempotent Bash install script based on the following request: $desc. Use package managers like apt, pip, npm, and include safety checks, comments, and error handling." | ollama run llama3






tree /opt/omniscient | curl -s http://192.168.12.104:11434/api/generate \
  -H "Content-Type: application/json" \
  -d '{"model":"llama3","prompt":"Here is the directory structure of a system:\n'"$(</dev/stdin)"'\n\nDoes this disk layout suggest a modular or monolithic architecture? Identify strengths, weaknesses, and potential risks in how this system is organized. Suggest improvements for scalability, maintainability, and security."}' \
  | jq -r .response



sudo du -h / --max-depth=2 2>/dev/null | sort -hr | head -n 30 | curl -s http://192.168.12.104:11434/api/generate \
  -H "Content-Type: application/json" \
  -d '{"model":"llama3","prompt":"Below is a snapshot of this system's top-level disk usage:\n'"$(</dev/stdin)"'\n\nReflect on which directories consume the most space and why. What patterns are present? Recommend how to refactor or optimize the system layout to better support long-term maintainability and security."}' \
  | jq -r .response



fdupes -r /opt/omniscient /opt/sdb1 | curl -s http://192.168.12.104:11434/api/generate \
  -H "Content-Type: application/json" \
  -d '{"model":"llama3","prompt":"Here is a list of duplicate files found in the system:\n'"$(</dev/stdin)"'\n\nAnalyze why these duplicates may exist. Are they caused by versioning, poor folder structure, or redundant backups? Suggest how I should deduplicate and refactor the system to reduce risk and improve efficiency."}' \
  | jq -r .response



#!/bin/bash

source "$(dirname "$0")/.env" 2>/dev/null

COMMAND=$1
SUBCOMMAND=$2

case "$COMMAND" in
  help)
    echo "Usage: omniscientctl [command] [option]"
    echo "Available commands:"
    echo "  start dashboard        # Launch Streamlit or Flask dashboard"
    echo "  run osint              # Execute OSINT tools pipeline"
    echo "  load forensic_tool     # Launch forensic module interface"
    ;;
  start)
    if [[ "$SUBCOMMAND" == "dashboard" ]]; then
      echo "[+] Launching dashboard..."
      python3 scripts/python/gui_deb_installer_x.py  # or streamlit run dashboard.py
    else
      echo "[✘] Unknown start target: $SUBCOMMAND"
    fi
    ;;
  run)
    if [[ "$SUBCOMMAND" == "osint" ]]; then
      echo "[+] Running OSINT pipeline..."
      bash scripts/bash/launch_osint_pipeline.sh  # or your real launcher
    else
      echo "[✘] Unknown run target: $SUBCOMMAND"
    fi
    ;;
  load)
    if [[ "$SUBCOMMAND" == "forensic_tool" ]]; then
      echo "[+] Loading forensic toolkit..."
      python3 scripts/python/vulnerability_scanner.py  # or another tool
    else
      echo "[✘] Unknown load target: $SUBCOMMAND"
    fi
    ;;
  *)
    echo "[✘] Unknown command: $COMMAND"
    echo "Run 'omniscientctl help' for usage."
    ;;
esac

# ===== END: /opt/omniscient/dev/control/dropoff/merge_compile_code.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/dropoff/omniscientctl.bak =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Auto-source the environment
[ -f /opt/omniscient/.env ] && source /opt/omniscient/.env

OMNIROOT="/opt/omniscient"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $@" >> "$LOG"

# Load config values with crudini if available
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
    MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
    LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
    OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
    OPENAI_API_KEY=$(crudini --get "$CONF" openai API_KEY 2>/dev/null || echo "")
else
    MODEL="gpt4all"
    LOG_LEVEL="INFO"
    OLLAMA_API="http://localhost:11434/api/generate"
    OPENAI_API_KEY=""
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
    for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# Default to help if no arguments
[[ -z "$1" ]] && set -- "help"

case "$1" in
    "omnieye-module")
        bash "$OMNIROOT/omnieye-blackbox/omnieye_module.sh" || echo "[!] Failed to run omnieye-module" >> "$LOG"
        ;;

    "prompt")
        prompt="$2"
        engine=${3:-$MODEL}

        case "$engine" in
            "ollama")
                response=$(curl -s -X POST "$OLLAMA_API" \
                    -H "Content-Type: application/json" \
                    -d "{\"model\": \"$MODEL\", \"prompt\": \"$prompt\"}")
                echo -e "\033[1;32mAI (Ollama):\033[0m $(echo "$response" | jq -r '.response // .result')"
                ;;

            "openai")
                if [[ -z "$OPENAI_API_KEY" ]]; then
                    echo "[!] Missing OpenAI API key in config." | tee -a "$LOG"
                    exit 1
                fi
                python3 -c "
import os, openai
openai.api_key = '$OPENAI_API_KEY'
response = openai.ChatCompletion.create(
    model='gpt-4',
    messages=[{'role': 'user', 'content': '$prompt'}]
)
print('\033[1;34mAI (OpenAI):\033[0m', response['choices'][0]['message']['content'])
" || echo "[!] OpenAI API call failed" >> "$LOG"
                ;;

            "gpt4all")
                python3 -c "
from pathlib import Path
from dotenv import load_dotenv
load_dotenv('$OMNIROOT/.env')
from gpt4all import GPT4All
model = GPT4All(model_name='$MODEL')
with model:
    output = model.generate(prompt='$prompt', temp=0.7)
    print('\033[1;36mAI (GPT4All):\033[0m', output)
" || echo "[!] GPT4All execution failed" >> "$LOG"
                ;;

            *)
                echo "[!] Unknown engine: $engine" | tee -a "$LOG"
                ;;
        esac
        ;;

    "logs")
        tail -n 50 "$LOG"
        ;;

    "help")
        echo -e "\nOmniscient CLI Usage:\n"
        echo "  omniscientctl prompt \"<prompt text>\" [engine]   Send prompt to selected engine (gpt4all, ollama, openai)"
        echo "  omniscientctl omnieye-module                     Run the Omnieye subsystem"
        echo "  omniscientctl logs                                Tail the last 50 log entries"
        echo "  omniscientctl help                                Show this help message"
        ;;

    *)
        echo "[!] Unknown command: $1" | tee -a "$LOG"
        exec "$0" help
        ;;
esac






\_omniscientctl_completions()
{
  local cmds="prompt omnieye-module logs help"
  local engines="gpt4all openai ollama lmstudio"
  COMPREPLY=()

  case "${COMP_CWORD}" in
    1)
      COMPREPLY=( $(compgen -W "$cmds" -- "${COMP_WORDS[1]}") )
      ;;
    2)
      if [[ "${COMP_WORDS[1]}" == "prompt" ]]; then
        COMPREPLY=( $(compgen -W "\"<prompt here>\"" -- "${COMP_WORDS[2]}") )
      fi
      ;;
    3)
      if [[ "${COMP_WORDS[1]}" == "prompt" ]]; then
        COMPREPLY=( $(compgen -W "$engines" -- "${COMP_WORDS[3]}") )
      fi
      ;;
  esac
}

complete -F _omniscientctl_completions omniscientctl




create_module() {
    local mod_name="$1"
    local mod_dir="$OMNIROOT/modules"
    local mod_file="$mod_dir/mod_${mod_name}.sh"

    if [[ -z "$mod_name" ]]; then
        echo "[✘] Please specify a module name."
        return 1
    fi

    if [[ ! -d "$mod_dir" ]]; then
        mkdir -p "$mod_dir"
    fi

    if [[ -f "$mod_file" ]]; then
        echo "[✘] Module '$mod_name' already exists at $mod_file"
        return 1
    fi

    cat > "$mod_file" << EOF
#!/bin/bash

mod_${mod_name}() {
    echo "Module '$mod_name' loaded!"
    # TODO: Add your module logic here
}

EOF

    chmod +x "$mod_file"
    echo "[✔] Module '$mod_name' created at $mod_file"
    echo "Add 'mod_${mod_name}' to your omniscientctl case statement to enable it."
}


# ===== END: /opt/omniscient/dev/control/dropoff/omniscientctl.bak =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl_merge =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Auto-source the environment
[ -f /opt/omniscient/.env ] && source /opt/omniscient/.env

OMNIROOT="/opt/omniscient"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"

# Load config values with crudini if available
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
    MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
    LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
    OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
    MODEL="gpt4all"
    LOG_LEVEL="INFO"
    OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
    for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# --------------------------
# Module auto-registration
# --------------------------
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
    for mod_file in "$MODULE_DIR"/mod_*.sh; do
        [[ -f "$mod_file" ]] || continue
        mod_basename=$(basename "$mod_file" .sh)
        mod_name=${mod_basename#mod_}

        # Check if module enabled in config (default true)
        enabled="true"
        if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
            enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
        fi

        if [[ "$enabled" == "true" ]]; then
            source "$mod_file"
            MODULES["$mod_name"]="mod_${mod_name}"
        fi
    done
fi

# --------------------------
# Helper functions
# --------------------------

show_help() {
    echo -e "\nOmniscient CLI Usage:\n"
    echo "  omniscientctl <command> [args...]"
    echo
    echo "Available commands from modules:"
    for cmd in "${!MODULES[@]}"; do
        help_func="mod_${cmd}_help"
        if declare -f "$help_func" > /dev/null; then
            echo -n "  $cmd - "
            $help_func
        else
            echo "  $cmd"
        fi
    done
    echo
    echo "Additional commands:"
    echo "  prompt \"<text>\" [engine]   Send prompt to engine (gpt4all, ollama, openai)"
    echo "  omnieye-module              Run the Omnieye subsystem"
    echo "  logs                       Tail last 50 log entries"
    echo "  version                    Show module versions"
    echo "  test-module <mod>          Run tests for module"
    echo "  help                       Show this help message"
    echo
}

show_versions() {
    echo "Omniscient Framework Modules Versions:"
    for cmd in "${!MODULES[@]}"; do
        # try to print MOD_VERSION if set
        mod_version_var="MOD_VERSION"
        # We rely on modules sourced already, so MOD_VERSION should be set per module
        # We prefix variable by mod_name to avoid conflicts
        version_var_name="MOD_VERSION_${cmd}"
        # fallback to generic MOD_VERSION if unique version vars aren't used
        version="${MOD_VERSION:-unknown}"

        # Check if module defines its own MOD_VERSION variable prefixed by module name
        version="$(eval echo \${MOD_VERSION_${cmd}:-$version})"
        echo "  $cmd : $version"
    done
}

run_module_test() {
    local mod="$1"
    local test_func="mod_${mod}_test"

    if [[ -z "$mod" ]]; then
        echo "[✘] Specify a module to test"
        return 1
    fi

    if ! declare -f "$test_func" > /dev/null; then
        echo "[!] No tests defined for module '$mod'"
        return 1
    fi

    echo "[*] Running tests for module '$mod'..."
    $test_func
}

# --------------------------
# Argument parsing
# --------------------------

if [[ -z "$1" ]]; then
    set -- help
fi

case "$1" in
    help)
        show_help
        exit 0
        ;;

    version)
        show_versions
        exit 0
        ;;

    test-module)
        shift
        run_module_test "$1"
        exit $?
        ;;

    prompt)
        prompt_text="$2"
        engine="${3:-$MODEL}"

        if [[ -z "$prompt_text" ]]; then
            echo "[✘] Please provide prompt text."
            exit 1
        fi

        if [[ "$engine" == "ollama" ]]; then
            response=$(curl -s -X POST "$OLLAMA_API" \
                -H "Content-Type: application/json" \
                -d "{\"model\": \"$MODEL\", \"prompt\": \"$prompt_text\"}")
            echo -e "\033[1;32mAI (Ollama):\033[0m $(echo "$response" | jq -r '.response // .result')"
        elif [[ "$engine" == "openai" ]]; then
            python3 -c "
import os, sys, openai
openai.api_key = os.getenv('OPENAI_API_KEY')
try:
    completion = openai.ChatCompletion.create(
        model='$MODEL',
        messages=[{'role': 'user', 'content': '$prompt_text'}]
    )
    print('\033[1;32mAI (OpenAI):\033[0m ' + completion.choices[0].message.content.strip())
except Exception as e:
    print('[✘] OpenAI request failed:', e)
"
        else
            # default or gpt4all or any other model, just run python script or binary
            python3 -c "
import sys
print(f'AI ({engine}): {prompt_text}')
# Placeholder for other engine integrations
"
        fi
        exit 0
        ;;

    omnieye-module)
        bash "$OMNIROOT/omnieye-blackbox/omnieye_module.sh"
        exit $?
        ;;

    logs)
        tail -n 50 "$LOG"
        exit 0
        ;;

    *)
        # Try to run module command if exists
        cmd="$1"
        if [[ -n "${MODULES[$cmd]}" ]]; then
            func="${MODULES[$cmd]}"
            shift
            $func "$@"
            exit $?
        else
            echo "[✘] Unknown command: $cmd"
            echo "Run 'omniscientctl help' for usage."
            exit 1
        fi
        ;;
esac

#!/bin/bash
# omniscientctl: Central management utility for Omniscient Framework

# Load environment variables
source /opt/omniscient/.autoenv/activate.sh

# Log file
LOGFILE="$PROMPT_LOG"

# Function: Log actions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$LOGFILE"
}

# Function: Display menu
show_menu() {
  echo "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Show system status"
  echo "6) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) show_status;;
    6) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

# Function: View core Omniscient environment variables
view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

# Function: Run AI summary process (mock/demo)
run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "Summary written to: $SUMMARY_LOG"
  echo "" >> "$SUMMARY_LOG"
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

# Function: Trigger maintenance job manually
trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

# Function: Start core services
start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

# Function: Show system status
show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"
  df -h | grep -E '/$|/opt|/var'
  echo "Memory:"
  free -h | grep -v Swap
  show_menu
}

# Entry point
clear
show_menu

# ===== END: /opt/omniscient/dev/control/omniscientctl_merge =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.my.bak.txt =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Auto-source the environment
[ -f /opt/omniscient/.env ] && source /opt/omniscient/.env
source /opt/omniscient/.autoenv/activate.sh


OMNIROOT="/opt/omniscient"
SCRIPT_DIRS=("ai" "core" "bin" "menus" "modules" "malformed" "offensive" "system" "scripts" "osint" "logs")


OMNIDIR="/opt/omniscient/control/omniscientctl.d"

# Load drop-ins
for f in "$OMNIDIR"/*.bash; do
    [[ -f "$f" ]] && source "$f"
done

# Dispatcher
case "$1" in
    ai|ai-pipe) cmd_ai_pipe "${@:2}" ;;
    backup|backupctl) cmd_backupctl "${@:2}" ;;
    *) echo "Unknown command: $1"; exit 1 ;;
esac



OMNIROOT="/opt/omniscient"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"


browse_directories() {
  echo -e "\n📂 Available Script Categories:"
  select dir in "${SCRIPT_DIRS[@]}" "Back"; do
    if [[ "$dir" == "Back" ]]; then
      show_menu
      return
    fi

    TARGET="$OMNIROOT/$dir"
    if [[ -d "$TARGET" ]]; then
      echo -e "\n📁 $dir Directory Contents:"
      files=("$TARGET"/*.sh "$TARGET"/*.bash)
      select file in "${files[@]}" "Back"; do
        if [[ "$file" == "Back" ]]; then
          browse_directories
          return
        elif [[ -f "$file" ]]; then
          echo -e "\n🚀 Executing: $file\n"
          log_action "Executing user script: $file"
          bash "$file"
          break
        else
          echo "Invalid selection. Try again."
        fi
      done
    else
      echo "[✘] Directory not found: $TARGET"
    fi
    break
  done
}


show_menu() {
  echo -e "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Restart core services"
  echo "6) Stop core services"
  echo "7) Check service health"
  echo "8) Show system status"
  echo "9) Run plugins"
  echo "10) Explore script directories"
  echo "11) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) restart_services;;
    6) stop_services;;
    7) health_check;;
    8) show_status;;
    9) run_plugins;;
    10) browse_directories;;
    11) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}



# Load config values with crudini if available
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
    MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
    LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
    OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
    MODEL="gpt4all"
    LOG_LEVEL="INFO"
    OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
    for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
        [[ -f "$path" ]] && source "$path" && break
    done
fi

# --------------------------
# Module auto-registration
# --------------------------
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
    for mod_file in "$MODULE_DIR"/mod_*.sh; do
        [[ -f "$mod_file" ]] || continue
        mod_basename=$(basename "$mod_file" .sh)
        mod_name=${mod_basename#mod_}

        # Check if module enabled in config (default true)
        enabled="true"
        if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
            enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
        fi

        if [[ "$enabled" == "true" ]]; then
            source "$mod_file"
            MODULES["$mod_name"]="mod_${mod_name}"
        fi
    done
fi

# --------------------------
# Helper functions
# --------------------------

log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$PROMPT_LOG"
}

# --------------------------
# Rsyslog command wrappers
# --------------------------

rsyslog_start() {
  sudo systemctl start rsyslog
  echo "rsyslog service started."
}

rsyslog_stop() {
  sudo systemctl stop rsyslog
  echo "rsyslog service stopped."
}

rsyslog_restart() {
  sudo systemctl restart rsyslog
  echo "rsyslog service restarted."
}

rsyslog_status() {
  sudo systemctl status rsyslog
}

rsyslog_reload() {
  sudo systemctl reload rsyslog
  echo "rsyslog service reloaded."
}

show_help() {
    echo -e "\nOmniscient CLI Usage:\n"
    echo "  omniscientctl <command> [args...]"
    echo
    echo "Available commands from modules:"
    for cmd in "${!MODULES[@]}"; do
        help_func="mod_${cmd}_help"
        if declare -f "$help_func" > /dev/null; then
            echo -n "  $cmd - "
            $help_func
        else
            echo "  $cmd"
        fi
    done
    echo
    echo "Additional commands:"
    echo "  prompt \"<text>\" [engine]   Send prompt to engine (gpt4all, ollama, openai)"
    echo "  omnieye-module              Run the Omnieye subsystem"
    echo "  logs                       Tail last 50 log entries"
    echo "  version                    Show module versions"
    echo "  test-module <mod>          Run tests for module"
    echo "  help                       Show this help message"
    echo
}

show_versions() {
    echo "Omniscient Framework Modules Versions:"
    for cmd in "${!MODULES[@]}"; do
        # try to print MOD_VERSION if set
        mod_version_var="MOD_VERSION"
        # We rely on modules sourced already, so MOD_VERSION should be set per module
        # We prefix variable by mod_name to avoid conflicts
        version_var_name="MOD_VERSION_${cmd}"
        # fallback to generic MOD_VERSION if unique version vars aren't used
        version="${MOD_VERSION:-unknown}"

        # Check if module defines its own MOD_VERSION variable prefixed by module name
        version="$(eval echo \${MOD_VERSION_${cmd}:-$version})"
        echo "  $cmd : $version"
    done
}

run_module_test() {
    local mod="$1"
    local test_func="mod_${mod}_test"

    if [[ -z "$mod" ]]; then
        echo "[✘] Specify a module to test"
        return 1
    fi

    if ! declare -f "$test_func" > /dev/null; then
        echo "[!] No tests defined for module '$mod'"
        return 1
    fi

    echo "[*] Running tests for module '$mod'..."
    $test_func
}

# --------------------------
# Interactive Menu Functions
# --------------------------

() {
  echo -e "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Show system status"
  echo "6) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) show_status;;
    6) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "Summary written to: $SUMMARY_LOG"
  echo "" >> "$SUMMARY_LOG"
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echshow_menuo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"
  df -h | grep -E '/$|/opt|/var'
  echo "Memory:"
  free -h | grep -v Swap
  show_menu
}

# --------------------------
# CLI Entry Point
# --------------------------

if [[ -z "$1" ]]; then
    clear
    show_menu
    exit 0
fi

case "$1" in
    help)
        show_help
        exit 0
        ;;
    version)
        show_versions
        exit 0
        ;;
    test-module)
        shift
        run_module_test "$1"
        exit $?
        ;;
    prompt)
        prompt_text="$2"
        engine="${3:-$MODEL}"

        if [[ -z "$prompt_text" ]]; then
            echo "[✘] Please provide prompt text."
            exit 1
        fi

        if [[ "$engine" == "ollama" ]]; then
            response=$(curl -s -X POST "$OLLAMA_API" \
                -H "Content-Type: application/json" \
                -d "{\"model\": \"$MODEL\", \"prompt\": \"$prompt_text\"}")
            echo -e "\033[1;32mAI (Ollama):\033[0m $(echo "$response" | jq -r '.response // .result')"
        elif [[ "$engine" == "openai" ]]; then
            python3 -c "
import os, sys, openai
openai.api_key = os.getenv('OPENAI_API_KEY')
try:
    completion = openai.ChatCompletion.create(
        model='$MODEL',
        messages=[{'role': 'user', 'content': '$prompt_text'}]
    )
    print('\033[1;32mAI (OpenAI):\033[0m ' + completion.choices[0].message.content.strip())
except Exception as e:
    print('[✘] OpenAI request failed:', e)
"
        else
            # default or gpt4all or any other model, just run python script or binary
            python3 -c "
import sys
print(f'AI ({engine}): {prompt_text}')
# Placeholder for other engine integrations
"
        fi
        exit 0
        ;;
    omnieye-module)
        bash "$OMNIROOT/omnieye-blackbox/omnieye_module.sh"
        exit $?
        ;;
    logs)
        tail -n 50 "$LOG"
        exit 0
        ;;
    rsyslog)
        shift
        case "$1" in
            start)
                rsyslog_start
                ;;
            stop)
                rsyslog_stop
                ;;
            restart)
                rsyslog_restart
                ;;
            status)
                rsyslog_status
                ;;
            reload)
                rsyslog_reload
                ;;
            *)
                echo "Usage: omniscientctl rsyslog {start|stop|restart|status|reload}"
                exit 1
                ;;
        esac
        exit 0
        ;;
    *)
        # Try to run module command if exists
        cmd="$1"
        if [[ -n "${MODULES[$cmd]}" ]]; then
            func="${MODULES[$cmd]}"
            shift
            $func "$@"
            exit $?
        else
            echo "[✘] Unknown command: $cmd"
            echo "Run 'omniscientctl help' for usage."
            exit 1
        fi
        ;;
esac

# ===== END: /opt/omniscient/dev/control/omniscientctl.my.bak.txt =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctlv1.2.sh =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK CLI ─────────────────────────────────────────

# Version
OMNISCIENTCTL_VERSION="1.0.0"

# Auto-source environment
OMNIROOT="/opt/omniscient"
[ -f "$OMNIROOT/.env" ] && source "$OMNIROOT/.env"
source "$OMNIROOT/.autoenv/activate.sh"

SCRIPT_DIRS=("ai" "core" "bin" "menus" "modules" "malformed" "offensive" "system" "scripts" "osint" "logs")
OMNIDIR="$OMNIROOT/control/omniscientctl.d"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
PROMPT_LOG="${PROMPT_LOG:-$OMNIROOT/logs/prompt.log}"

mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"

# Load drop-in shell modules
for f in "$OMNIDIR"/*.bash; do [[ -f "$f" ]] && source "$f"; done

# Helper Functions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$PROMPT_LOG"
}

restart_services() {
  log_action "Restarting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Restarting $service..."
    sudo systemctl restart "$service"
  done
  show_menu
}

stop_services() {
  log_action "Stopping core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Stopping $service..."
    sudo systemctl stop "$service"
  done
  show_menu
}

health_check() {
  log_action "Checking health of core services"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    STATUS=$(systemctl is-active "$service")
    echo "$service → $STATUS"
  done
  show_menu
}

run_plugins() {
  local plugin_dir="${OMNISCIENT_PLUGIN_DIR:-$OMNIROOT/plugins}"
  echo -e "\n🗙 Executing plugins in $plugin_dir"
  for plugin in "$plugin_dir"/*.sh; do
    [ -x "$plugin" ] && echo "→ Running $(basename "$plugin")" && bash "$plugin"
  done
  show_menu
}

browse_directories() {
  echo -e "\n📂 Available Script Categories:"
  select dir in "${SCRIPT_DIRS[@]}" "Back"; do
    [[ "$REPLY" == $(( ${#SCRIPT_DIRS[@]} + 1 )) ]] && show_menu && return
    TARGET="$OMNIROOT/$dir"
    if [[ -d "$TARGET" ]]; then
      echo -e "\n📁 $dir Directory Contents:"
      mapfile -t files < <(find "$TARGET" -maxdepth 1 -type f \( -name "*.sh" -o -name "*.bash" \))
      select file in "${files[@]}" "Back"; do
        [[ "$REPLY" == $(( ${#files[@]} + 1 )) ]] && browse_directories && return
        if [[ -f "$file" ]]; then
          echo -e "\n📄 Previewing script: $file"
          log_action "Previewing user script: $file"
          head -n 50 "$file" | nl
          echo -e "\n[?] Execute this script? (y/n): "
          read -r exec_choice
          if [[ "$exec_choice" =~ ^[Yy]$ ]]; then
            bash "$file"
          else
            echo "Skipped execution."
          fi
        else
          echo "Invalid selection. Try again."
        fi
        break
      done
    else
      echo "[✘] Directory not found: $TARGET"
    fi
    break
  done
}

# Load config values
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
  MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
  LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
  OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
  MODEL="gpt4all"; LOG_LEVEL="INFO"; OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
  for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
    [[ -f "$path" ]] && source "$path" && break
  done
fi

# Auto-register modules
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
  for mod_file in "$MODULE_DIR"/mod_*.sh; do
    [[ -f "$mod_file" ]] || continue
    mod_basename=$(basename "$mod_file" .sh)
    mod_name=${mod_basename#mod_}
    enabled="true"
    if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
      enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
    fi
    if [[ "$enabled" == "true" ]]; then
      source "$mod_file"
      MODULES["$mod_name"]="mod_${mod_name}"
    fi
  done
fi

# Menu Functions
show_menu() {
  echo -e "\n🧐 Omniscient Control Panel"
  echo "──────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Restart core services"
  echo "6) Stop core services"
  echo "7) Check service health"
  echo "8) Show system status"
  echo "9) Run plugins"
  echo "10) Explore script directories"
  echo "11) Show version info"
  echo "12) Exit"
  echo "──────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) restart_services;;
    6) stop_services;;
    7) health_check;;
    8) show_status;;
    9) run_plugins;;
    10) browse_directories;;
    11) show_versions;;
    12) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

show_versions() {
  echo "\n🦖 OmniscientCTL Version: $OMNISCIENTCTL_VERSION"
  if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null; then
    branch=$(git rev-parse --abbrev-ref HEAD)
    commit=$(git rev-parse --short HEAD)
    echo "🔖 Git: Branch [$branch], Commit [$commit]"
  fi
  echo "📂 Framework Modules:"
  for cmd in "${!MODULES[@]}"; do
    version_var="MOD_VERSION_${cmd}"
    version="${!version_var:-${MOD_VERSION:-unknown}}"
    echo "  $cmd : $version"
  done
  show_menu
}

# Placeholder function stubs for completeness
view_environment() {
  log_action "Displaying Omniscien
# ===== END: /opt/omniscient/dev/control/omniscientctlv1.2.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl1 =====
#!/usr/bin/env bash

# Set global variables
OMNISCIENT_DIR="/opt/omniscient"
VENV_DIR="$OMNISCIENT_DIR/venv"
LOGFILE="$OMNISCIENT_DIR/logs/omniscientctl.log"

# Activate virtual environment silently
source "$VENV_DIR/bin/activate" 2>/dev/null

# Log function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOGFILE"
}

# Run a command with logging
run_cmd() {
    log "$1"
    shift
    "$@"
}

# Navigate to a directory and run a command
launch_gui() {
    local dir="$1"
    local cmd="$2"
    if cd "$dir" 2>/dev/null; then
        run_cmd "Launching interface in $dir..." $cmd
    else
        log "Directory $dir not found. Exiting."
        exit 1
    fi
}

# Execute a script file with logging
exec_script() {
    local script="$1"
    if [[ -x "$script" || -f "$script" ]]; then
        run_cmd "Executing $script..." bash "$script"
    else
        log "Script $script not found or not executable."
        exit 1
    fi
}

# Command handler
case "$1" in
    start)
        run_cmd "Starting Omniscient service..." systemctl start omniscient.service
        ;;
    stop)
        run_cmd "Stopping Omniscient service..." systemctl stop omniscient.service
        ;;
    restart)
        run_cmd "Restarting Omniscient service..." systemctl restart omniscient.service
        ;;
    status)
        systemctl status omniscient.service
        ;;
    gui)
        launch_gui "$OMNISCIENT_DIR/web" "python3 app.py"
        ;;
    streamlit)
        launch_gui "$OMNISCIENT_DIR/web" "streamlit run dashboard.py"
        ;;
    logs)
        run_cmd "Opening Omniscient logs..." less "$LOGFILE"
        ;;
    update)
        run_cmd "Updating Omniscient framework..." git -C "$OMNISCIENT_DIR" pull
        exec_script "$OMNISCIENT_DIR/init/setup_omniscient.sh"
        ;;
    install)
        exec_script "$OMNISCIENT_DIR/init/setup_omniscient.sh"
        ;;
    shell)
        run_cmd "Launching interactive AI shell..." python3 "$OMNISCIENT_DIR/ai/interactive_shell.py"
        ;;
    backup)
        exec_script "$OMNISCIENT_DIR/scripts/backup.sh"
        ;;
    help|-h|--help)
        cat <<EOF

Omniscient Framework Control Utility

Usage:
  omniscientctl <command>

Commands:
  start         Start Omniscient service
  stop          Stop Omniscient service
  restart       Restart Omniscient service
  status        Show service status
  gui           Launch Flask interface
  streamlit     Launch Streamlit dashboard
  logs          View omniscientctl log
  update        Pull latest Omniscient updates and run setup
  install       Run Omniscient system installer
  shell         Launch AI-powered local shell
  backup        Run backup routine
  help          Show this help message

EOF
        ;;
    *)
        echo "Invalid command: '$1'"
        echo "Use 'omniscientctl help' for a list of available commands."
        exit 1
        ;;
esac

# ===== END: /opt/omniscient/dev/control/omniscientctl1 =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctlv1.sh =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK CLI ───────────────────────────────────────────────

# Version
OMNISCIENTCTL_VERSION="1.0.0"

# Auto-source environment
OMNIROOT="/opt/omniscient"
[ -f "$OMNIROOT/.env" ] && source "$OMNIROOT/.env"
source "$OMNIROOT/.autoenv/activate.sh"

SCRIPT_DIRS=("ai" "core" "bin" "menus" "modules" "malformed" "offensive" "system" "scripts" "osint" "logs")
OMNIDIR="$OMNIROOT/control/omniscientctl.d"
CONF="$OMNIROOT/omniscient.conf"
LOG="$OMNIROOT/logs/omniscientctl.log"
PROMPT_LOG="${PROMPT_LOG:-$OMNIROOT/logs/prompt.log}"

mkdir -p "$(dirname "$LOG")"
echo "[+] OmniscientCTL invoked at $(date) with args: $*" >> "$LOG"

# Load drop-in shell modules
for f in "$OMNIDIR"/*.bash; do [[ -f "$f" ]] && source "$f"; done

# Helper Functions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$PROMPT_LOG"
}

restart_services() {
  log_action "Restarting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Restarting $service..."
    sudo systemctl restart "$service"
  done
  show_menu
}

stop_services() {
  log_action "Stopping core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Stopping $service..."
    sudo systemctl stop "$service"
  done
  show_menu
}

health_check() {
  log_action "Checking health of core services"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    STATUS=$(systemctl is-active "$service")
    echo "$service → $STATUS"
  done
  show_menu
}

run_plugins() {
  local plugin_dir="${OMNISCIENT_PLUGIN_DIR:-$OMNIROOT/plugins}"
  echo -e "\n🗉 Executing plugins in $plugin_dir"
  for plugin in "$plugin_dir"/*.sh; do
    [ -x "$plugin" ] && echo "→ Running $(basename "$plugin")" && bash "$plugin"
  done
  show_menu
}

browse_directories() {
  echo -e "\n📂 Available Script Categories:"
  select dir in "${SCRIPT_DIRS[@]}" "Back"; do
    [[ "$REPLY" == $(( ${#SCRIPT_DIRS[@]} + 1 )) ]] && show_menu && return
    TARGET="$OMNIROOT/$dir"
    if [[ -d "$TARGET" ]]; then
      echo -e "\n📁 $dir Directory Contents:"
      mapfile -t files < <(find "$TARGET" -maxdepth 1 -type f \( -name "*.sh" -o -name "*.bash" \))
      select file in "${files[@]}" "Back"; do
        [[ "$REPLY" == $(( ${#files[@]} + 1 )) ]] && browse_directories && return
        if [[ -f "$file" ]]; then
          echo -e "\n📄 Previewing script: $file"
          log_action "Previewing user script: $file"
          head -n 50 "$file" | nl
          echo -e "\n[?] Execute this script? (y/n): "
          read -r exec_choice
          if [[ "$exec_choice" =~ ^[Yy]$ ]]; then
            bash "$file"
          else
            echo "Skipped execution."
          fi
        else
          echo "Invalid selection. Try again."
        fi
        break
      done
    else
      echo "[\u2718] Directory not found: $TARGET"
    fi
    break
  done
}

# Load config values
if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
  MODEL=$(crudini --get "$CONF" models MODEL_BACKEND 2>/dev/null || echo "gpt4all")
  LOG_LEVEL=$(crudini --get "$CONF" core LOG_LEVEL 2>/dev/null || echo "INFO")
  OLLAMA_API=$(crudini --get "$CONF" ollama API_URL 2>/dev/null || echo "http://localhost:11434/api/generate")
else
  MODEL="gpt4all"; LOG_LEVEL="INFO"; OLLAMA_API="http://localhost:11434/api/generate"
fi

# Activate Python virtual environment
if [[ -z "$VIRTUAL_ENV" ]]; then
  for path in "$OMNIROOT/venv/bin/activate" "$OMNIROOT/bin/activate" "$OMNIROOT/.env/bin/activate"; do
    [[ -f "$path" ]] && source "$path" && break
  done
fi

# Auto-register modules
MODULE_DIR="$OMNIROOT/modules"
declare -A MODULES=()

if [[ -d "$MODULE_DIR" ]]; then
  for mod_file in "$MODULE_DIR"/mod_*.sh; do
    [[ -f "$mod_file" ]] || continue
    mod_basename=$(basename "$mod_file" .sh)
    mod_name=${mod_basename#mod_}
    enabled="true"
    if command -v crudini &> /dev/null && [[ -f "$CONF" ]]; then
      enabled=$(crudini --get "$CONF" modules "$mod_name" 2>/dev/null || echo "true")
    fi
    if [[ "$enabled" == "true" ]]; then
      source "$mod_file"
      MODULES["$mod_name"]="mod_${mod_name}"
    fi
  done
fi

# Menu Functions
show_menu() {
  echo -e "\n🧠 Omniscient Control Panel"
  echo "──────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Restart core services"
  echo "6) Stop core services"
  echo "7) Check service health"
  echo "8) Show system status"
  echo "9) Run plugins"
  echo "10) Explore script directories"
  echo "11) Show version info"
  echo "12) Exit"
  echo "──────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) restart_services;;
    6) stop_services;;
    7) health_check;;
    8) show_status;;
    9) run_plugins;;
    10) browse_directories;;
    11) show_versions;;
    12) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

show_versions() {
  echo "\n🧐 OmniscientCTL Version: $OMNISCIENTCTL_VERSION"
  if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null; then
    branch=$(git rev-parse --abbrev-ref HEAD)
    commit=$(git rev-parse --short HEAD)
    echo "🔖 Git: Branch [$branch], Commit [$commit]"
  fi
  echo "📂 Framework Modules:"
  for cmd in "${!MODULES[@]}"; do
    version_var="MOD_VERSION_${cmd}"
    version="${!version_var:-${MOD_VERSION:-unknown}}"
    echo "  $cmd : $version"
  done
  show_menu
}

# Placeholder function stubs for completeness
view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"; df -h | grep -E '/$|/opt|/var'
  echo "Memory:"; free -h | grep -v Swap
  show_menu
}

# CLI Entry Point
if [[ -z "$1" ]]; then
  clear
  show_menu
  exit 0
fi

case "$1" in
  version|--version|-v) show_versions; exit 0 ;;
  *) echo "[✘] Unknown command: $1"; show_menu; exit 1 ;;
esac

# ===== END: /opt/omniscient/dev/control/omniscientctlv1.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK HOOKS ────────────────────────────────────────────
# Load environment variables if sourced or run in isolated shell
[ -f /opt/omniscient/.bashrc ] && source /opt/omniscient/.bashrc

# Define key paths directly (if .bashrc isn't sourced)
OMNISCIENT="/opt/omniscient"
OMNISCIENT_LOGS="$OMNISCIENT/logs"
OMNISCIENT_HOME="$OMNISCIENT/home/$USER"
WHITERABBIT="$OMNISCIENT/ai/models/WhiteRabbitNeo-2.5-Qwen<attempt_completion>
<result>
I have reviewed the requested omniscientctl content to include the OMNISCIENT FRAMEWORK HOOKS section with environment variable loading and logging functions. However, the file edit failed due to size or formatting constraints.

Please confirm if you want me to proceed with incremental patch updates or provide the full updated omniscientctl file content in smaller parts for successful integration.

Additionally, please specify your preferred level of testing for the consolidated omniscientctl script:
- Critical-path testing (key elements only)
- Thorough testing (complete coverage)

This will ensure the final implementation is verified according to your requirements.
</result>
</attempt_completion>

# ===== END: /opt/omniscient/dev/control/omniscientctl =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl_autoenv =====
#!/usr/bin/env bash
# omniscientctl: Central management utility for Omniscient Framework

# Load environment variables
source /opt/omniscient/.autoenv/activate.sh

# Log file
LOGFILE="$PROMPT_LOG"

# Function: Log actions
log_action() {
  echo "[$(date +'%F %T')] $1" | tee -a "$LOGFILE"
}

# Function: Display menu
show_menu() {
  echo "\n🧠 Omniscient Control Panel"
  echo "────────────────────────────"
  echo "1) View system environment"
  echo "2) Run AI summary process"
  echo "3) Trigger scheduled maintenance"
  echo "4) Start core services"
  echo "5) Show system status"
  echo "6) Exit"
  echo "────────────────────────────"
  read -p "Enter selection: " choice
  case $choice in
    1) view_environment;;
    2) run_summary;;
    3) trigger_maintenance;;
    4) start_services;;
    5) show_status;;
    6) exit 0;;
    *) echo "Invalid option"; sleep 1; show_menu;;
  esac
}

# Function: View core Omniscient environment variables
view_environment() {
  log_action "Displaying Omniscient environment"
  env | grep -E 'OMNISCIENT_|SUMMARY_LOG|PROMPT_LOG|DEFAULT_MODEL|OLLAMA_API|IP_ADDRESS|GATEWAY|DNS_SERVERS'
  show_menu
}

# Function: Run AI summary process (mock/demo)
run_summary() {
  log_action "Invoking AI summary process..."
  echo "[AI] Generating daily summary..."
  echo "Summary written to: $SUMMARY_LOG"
  echo "" >> "$SUMMARY_LOG"
  echo "[$(date +'%F %T')] Auto summary: All systems nominal." >> "$SUMMARY_LOG"
  sleep 1
  show_menu
}

# Function: Trigger maintenance job manually
trigger_maintenance() {
  log_action "Triggering scheduled maintenance via: $PERIODIC_MAINTENANCE"
  if [[ -x "$PERIODIC_MAINTENANCE" ]]; then
    bash "$PERIODIC_MAINTENANCE"
  else
    echo "Maintenance script not found or not executable."
  fi
  show_menu
}

# Function: Start core services
start_services() {
  log_action "Starting core services: $SERVICES_TO_ENABLE"
  IFS=',' read -ra SERVICES <<< "$SERVICES_TO_ENABLE"
  for service in "${SERVICES[@]}"; do
    echo "Starting $service..."
    sudo systemctl start "$service"
  done
  show_menu
}

# Function: Show system status
show_status() {
  log_action "Gathering system status info"
  echo "Uptime: $(uptime -p)"
  echo "IP: $(hostname -I | awk '{print $1}')"
  echo "Disk:"
  df -h | grep -E '/$|/opt|/var'
  echo "Memory:"
  free -h | grep -v Swap
  show_menu
}

# Entry point
clear
show_menu

# ===== END: /opt/omniscient/dev/control/omniscientctl_autoenv =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/bootstrap.sh =====
#!/usr/bin/env bash

# ─── OMNISCIENT FRAMEWORK HOOKS ────────────────────────────────────────────
# Load environment variables if sourced or run in isolated shell
[ -f /opt/omniscient/.bashrc ] && source /opt/omniscient/.bashrc

# Define key paths directly (if .bashrc isn't sourced)
OMNISCIENT="/opt/omniscient"
OMNISCIENT_LOGS="$OMNISCIENT/logs"
OMNISCIENT_HOME="$OMNISCIENT/home/$USER"
WHITERABBIT="$OMNISCIENT/ai/models/WhiteRabbitNeo-2.5-Qwen-2.5-Coder-7B-IQ2_M.gguf"

# Default log
LOGFILE="$OMNISCIENT_LOGS/$(basename "$0" .sh).log"

# Timestamped logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOGFILE"
}

# ───────────────────────────────────────────────────────────────────────────


# ===== END: /opt/omniscient/dev/control/omniscientctl.d/bootstrap.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/merge_control_functions.sh =====
#!/usr/bin/env bash

CONTROL_DIR="./control"
MAIN="$CONTROL_DIR/omniscientctl"
ALT="$CONTROL_DIR/omniscientctl2"
BACKUP="$CONTROL_DIR/omniscientctl.bak.$(date +%Y%m%d_%H%M%S)"
MERGE_LOG="$CONTROL_DIR/omniscientctl_merge.log"

# === SAFETY CHECK ===
[[ ! -f "$MAIN" || ! -f "$ALT" ]] && echo "[ERROR] Main or alt script not found." && exit 1

# === BACKUP FIRST ===
cp "$MAIN" "$BACKUP"
echo "[BACKUP] Original omniscientctl backed up to $BACKUP"

# === FUNCTIONS TO ADD ===
FUNCS=("log_event" "usage")

# === APPEND TO MAIN ===
{
  echo -e "\n### === BEGIN MERGED FUNCTIONS from omniscientctl2 on $(date) ==="
  for fname in "${FUNCS[@]}"; do
    awk "/^\s*(function\s+)?$fname\s*\(\)\s*\{/,/^\}/" "$ALT"
    echo ""
  done
  echo "### === END MERGED FUNCTIONS ==="
} >> "$MAIN"

# === LOG ===
{
  echo "=== Merge on $(date) ==="
  echo "From: $ALT"
  echo "To:   $MAIN"
  echo "Added:"
  printf " - %s\n" "${FUNCS[@]}"
  echo "Backup: $BACKUP"
  echo "==========================="
} >> "$MERGE_LOG"

echo "[DONE] Functions merged: ${FUNCS[*]}"
echo "[LOG] See: $MERGE_LOG"

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/merge_control_functions.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/omniscient_bidirectional_async.sh =====
#!/usr/bin/env bash

# Define hosts and paths
REMOTE1="jeremy@engram"
REMOTE2="jeremy@aspire"
DIR="/opt/omniscient"
LOG="/opt/omniscient/logs/rsync_sync.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# Ensure log directory exists
mkdir -p "$(dirname "$LOG")"

echo "==== Sync started at $TIMESTAMP ====" >> "$LOG"

# Step 1: Rsync from REMOTE1 to REMOTE2
echo "[1] Syncing from $REMOTE1 to $REMOTE2..." | tee -a "$LOG"
ssh $REMOTE1 "rsync -avz --delete --update $DIR/ $REMOTE2:$DIR" >> "$LOG" 2>&1

# Step 2: Rsync from REMOTE2 to REMOTE1
echo "[2] Syncing from $REMOTE2 to $REMOTE1..." | tee -a "$LOG"
ssh $REMOTE2 "rsync -avz --delete --update $DIR/ $REMOTE1:$DIR" >> "$LOG" 2>&1

echo "[✓] Sync complete." | tee -a "$LOG"


# ===== END: /opt/omniscient/dev/control/omniscientctl.d/omniscient_bidirectional_async.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/modularize.sh =====
#!/usr/bin/env bash
set -e

echo "[*] Starting Omniscient modular framework structuring..."

BASE="/opt/omniscient"
mkdir -p \
  "$BASE/core" \
  "$BASE/bin" \
  "$BASE/ai" \
  "$BASE/forensics" \
  "$BASE/osint" \
  "$BASE/db" \
  "$BASE/conf" \
  "$BASE/logs" \
  "$BASE/backups" \
  "$BASE/gui" \
  "$BASE/www" \
  "$BASE/docs"

# Move known modules by logic
mv -v "$BASE"/ai "$BASE/ai/"
mv -v "$BASE"/bin/* "$BASE/bin/" || true
mv -v "$BASE"/compiled/* "$BASE/bin/" || true
mv -v "$BASE"/scripts/* "$BASE/bin/" || true
mv -v "$BASE"/factored_scripts/* "$BASE/bin/" || true
mv -v "$BASE"/init/* "$BASE/core/" || true
mv -v "$BASE"/management/* "$BASE/bin/" || true

mv -v "$BASE"/config/* "$BASE/conf/" || true
mv -v "$BASE"/omniscient.conf "$BASE/conf/" || true
mv -v "$BASE"/crons "$BASE/conf/" || true
mv -v "$BASE"/envs "$BASE/conf/" || true

mv -v "$BASE"/logs/* "$BASE/logs/" || true

mv -v "$BASE"/omnieye "$BASE/osint/" || true
mv -v "$BASE"/duckduckgosearch "$BASE/osint/" || true
mv -v "$BASE"/feedmeseymour "$BASE/osint/" || true
mv -v "$BASE"/pywebscrape "$BASE/osint/" || true
mv -v "$BASE"/crosstrax "$BASE/osint/" || true

mv -v "$BASE"/dockers "$BASE/core/" || true
mv -v "$BASE"/pdf2txtocr "$BASE/forensics/" || true
mv -v "$BASE"/pyfor "$BASE/forensics/" || true
mv -v "$BASE"/python3 "$BASE/forensics/" || true
mv -v "$BASE"/omniscinent_disk "$BASE/forensics/" || true
mv -v "$BASE"/rsysai.py "$BASE/forensics/" || true

mv -v "$BASE"/sql "$BASE/db/" || true
mv -v "$BASE"/sql_db_design_analysis "$BASE/db/" || true

mv -v "$BASE"/tkinter_gui.py "$BASE/gui/" || true
mv -v "$BASE"/templates "$BASE/www/" || true
mv -v "$BASE"/web "$BASE/www/" || true

mv -v "$BASE"/readme "$BASE/docs/" || true
mv -v "$BASE"/manpages "$BASE/docs/" || true
mv -v "$BASE"/framework_structure.log "$BASE/docs/" || true

mv -v "$BASE"/forgitboutit "$BASE/core/" || true
mv -v "$BASE"/for_git_master_repos_list "$BASE/core/" || true
mv -v "$BASE"/formakevenv "$BASE/core/" || true
mv -v "$BASE"/forwardxssh "$BASE/core/" || true

mv -v "$BASE"/omniscient.service "$BASE/core/" || true

mv -v "$BASE"/omniscient_backups "$BASE/backups/" || true
mv -v "$BASE"/omniscient_backup_soc "$BASE/backups/" || true

echo "[✓] Omniscient structure modularized."
tree "$BASE" || find "$BASE"

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/modularize.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/ollamapipe.sh =====
#!/usr/bin/env bash
# Dynamic Ollama universal AI pipeline
# Usage: omniscientctl ai pipe <mode> [input/file/stdin]

function cmd_ai_pipe() {
    local MODE="${1:-default}"         # summary, explain, codefix, etc.
    local INPUT="${2:-}"

    local TMPFILE=$(mktemp)
    local MODEL="${OLLAMA_MODEL:-llama3}"
    local LOGFILE="$HOME/.omniscient_logs/ollama_pipe.log"
    mkdir -p "$(dirname "$LOGFILE")"

    echo "[🧠] Running Ollama pipeline in mode: $MODE using model: $MODEL"

    # Handle input: direct string, stdin, or file
    if [[ -p /dev/stdin ]]; then
        cat - > "$TMPFILE"
    elif [[ -f "$INPUT" ]]; then
        cp "$INPUT" "$TMPFILE"
    elif [[ -n "$INPUT" ]]; then
        echo "$INPUT" > "$TMPFILE"
    else
        echo "Enter your input (Ctrl+D to finish):"
        cat - > "$TMPFILE"
    fi

    local PROMPT=""
    case "$MODE" in
        summary) PROMPT="Summarize the following in plain English:" ;;
        explain) PROMPT="Explain the following content:" ;;
        codefix) PROMPT="Fix and improve this code:" ;;
        *)       PROMPT="Process the following input meaningfully:" ;;
    esac

    echo "📝 Prompting Ollama..."
    echo "[$(date)] MODE=$MODE" >> "$LOGFILE"
    echo "---INPUT---" >> "$LOGFILE"
    cat "$TMPFILE" >> "$LOGFILE"

    # Run Ollama pipeline
    local RESPONSE
    RESPONSE=$(ollama run "$MODEL" <<< "$PROMPT"$(printf '\n')$(cat "$TMPFILE"))

    echo "---OUTPUT---" >> "$LOGFILE"
    echo "$RESPONSE" >> "$LOGFILE"
    echo "[✅] AI Output:"
    echo "$RESPONSE"
    echo "[📁] Logged to: $LOGFILE"
}

function register_wrappers() {
    declare -gA OMNI_COMMANDS
    OMNI_COMMANDS["ai_pipe"]="cmd_ai_pipe"
}

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/ollamapipe.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/modollama.sh =====
#!/usr/bin/env bash
# mod_ollama.sh - Ollama AI pipeline interface module

MOD_VERSION_ollama="1.0.0"

ollama_pipeline() {
  log_action "[LLM] Sending prompt to Ollama at $OLLAMA_API"

  echo "📥 Enter prompt for Ollama model (Ctrl+D to send):"
  user_input=$(</dev/stdin)

  response=$(curl -s -X POST "$OLLAMA_API" \
    -H "Content-Type: application/json" \
    -d '{"model": "'$MODEL'", "prompt": "'"${user_input//\"/\\\"}"'", "stream": false}')

  echo -e "\n[🔁 LLM Response]:"
  echo "$response" | jq -r '.response // .message.content // .output'
  echo ""
  show_menu
}

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/modollama.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/wrapgen.sh =====
#!/usr/bin/env bash
# omniscientctl_wrapgen - Auto-create omniscientctl wrappers for Linux commands

WRAPPER_DIR="/opt/omniscient/control/omniscientctl.d"
mkdir -p "$WRAPPER_DIR"

function usage() {
    echo "Usage: $0 <command_name>"
    echo "Example: $0 nmap"
    exit 1
}

[[ -z "$1" ]] && usage

COMMAND_NAME="$1"
FILENAME="$WRAPPER_DIR/${COMMAND_NAME}.bash"
FUNC_NAME="cmd_${COMMAND_NAME}"

# Avoid overwriting
if [[ -f "$FILENAME" ]]; then
    echo "❌ Wrapper already exists at $FILENAME"
    exit 1
fi

# Create wrapper file
cat <<EOF > "$FILENAME"
#!/usr/bin/env bash
# Auto-generated wrapper for '$COMMAND_NAME'

function $FUNC_NAME() {
    echo "[⚙️] Executing: $COMMAND_NAME \$*"
    command -v $COMMAND_NAME &>/dev/null || { echo "❌ Command '$COMMAND_NAME' not found."; return 127; }
    $COMMAND_NAME "\$@"
}

function register_wrappers() {
    declare -gA OMNI_COMMANDS
    OMNI_COMMANDS[$COMMAND_NAME]="$FUNC_NAME"
}
EOF

chmod +x "$FILENAME"

echo "✅ Created wrapper: $FILENAME"
echo "📦 Remember to restart or source omniscientctl to load the new wrapper!"

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/wrapgen.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/omniscient_venv_builder.sh =====
#!/usr/bin/env bash
set -e

OMNI_ROOT="/opt/omniscient"
VENV_DIR="$OMNI_ROOT/.venv"
PYTHON=$(which python3)

echo "[*] Creating Python virtual environment at $VENV_DIR..."
$PYTHON -m venv "$VENV_DIR"
source "$VENV_DIR/bin/activate"

echo "[*] Scanning for .py scripts and installing requirements where applicable..."

# Install core dependencies
pip install --upgrade pip

# Collect .py scripts and look for requirements.txt in matching folders
find "$OMNI_ROOT" -type f -name "*.py" | while read -r script; do
  script_dir=$(dirname "$script")
  if [[ -f "$script_dir/requirements.txt" ]]; then
    echo "[✓] Installing dependencies from $script_dir/requirements.txt"
    pip install -r "$script_dir/requirements.txt" || echo "[!] Failed: $script_dir"
  fi
done

echo "[✓] Virtual environment ready."
echo "To activate it: source $VENV_DIR/bin/activate"

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/omniscient_venv_builder.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/omniscient_protect.sh =====
#!/usr/bin/env bash
# Source this after defining /opt/omniscient layout and .env

source /opt/omniscient/.env || { echo "Missing .env"; exit 1; }

# Make protected directories immutable and read-only for all but owner
protect_dirs=("$OMNISCIENT_CONF" "$OMNISCIENT_DOCS" "$OMNISCIENT_DB")

for d in "${protect_dirs[@]}"; do
  if [ -d "$d" ]; then
    chmod -R a-w "$d"
    chattr -R +i "$d" 2>/dev/null || echo "Immutable flag requires root: $d"
  fi
done

# Custom cd shortcuts
alias cdbin="cd $OMNISCIENT_BIN"
alias cdai="cd $OMNISCIENT_AI"
alias cdgui="cd $OMNISCIENT_GUI"
alias cdlogs="cd $OMNISCIENT_LOGS"
alias cdconf="cd $OMNISCIENT_CONF"
alias cddb="cd $OMNISCIENT_DB"

echo "[✓] Omniscient environment protected and ready."

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/omniscient_protect.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/merge_omniscientctl_inline.sh =====
#!/usr/bin/env bash

# === CONFIGURATION ===
SCRIPT_DIR="./control"
MAIN_SCRIPT="$SCRIPT_DIR/omniscientctl"
INLINE_SCRIPT="$SCRIPT_DIR/omniscientctl_inline"
BACKUP_DIR="$SCRIPT_DIR/backups"
LOG_FILE="$SCRIPT_DIR/omniscientctl_merge.log"
TMP_FUNCS="/tmp/omniscientctl_new_funcs.tmp"

# === SAFETY FIRST ===
mkdir -p "$BACKUP_DIR"

[[ ! -f "$MAIN_SCRIPT" ]] && echo "[ERR] Main omniscientctl script not found at: $MAIN_SCRIPT" && exit 1
[[ ! -f "$INLINE_SCRIPT" ]] && echo "[ERR] Inline script not found at: $INLINE_SCRIPT" && exit 1

echo "[INFO] Working from directory: $SCRIPT_DIR"
echo "[INFO] Backups will be saved to: $BACKUP_DIR"

# === BACKUP MAIN SCRIPT ===
timestamp=$(date +"%Y%m%d_%H%M%S")
cp "$MAIN_SCRIPT" "$BACKUP_DIR/omniscientctl.bak.$timestamp"
echo "[BACKUP] Main script backed up as omniscientctl.bak.$timestamp"

# === FUNCTION NAME EXTRACTOR ===
extract_func_names() {
  grep -E '^\s*(function\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)\s*\{' "$1" \
  | sed -E 's/^\s*(function\s+)?([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\).*/\2/' \
  | sort -u
}

# === GATHER FUNCTION NAMES ===
main_funcs=$(extract_func_names "$MAIN_SCRIPT")
inline_funcs=$(extract_func_names "$INLINE_SCRIPT")

# === FIND NEW FUNCTION NAMES ===
new_funcs=()
while IFS= read -r func; do
  if ! grep -q -E "^\s*(function\s+)?$func\s*\(\)\s*\{" "$MAIN_SCRIPT"; then
    new_funcs+=("$func")
  fi
done <<< "$inline_funcs"

# === HANDLE NO NEW FUNCS ===
if [[ ${#new_funcs[@]} -eq 0 ]]; then
  echo "[OK] No new functions found. Everything is synced."
  exit 0
fi

# === EXTRACT FUNCTION BODIES ===
> "$TMP_FUNCS"
for func in "${new_funcs[@]}"; do
  awk "/^\s*(function\s+)?$func\s*\(\)\s*\{/,/^\}/" "$INLINE_SCRIPT" >> "$TMP_FUNCS"
  echo "" >> "$TMP_FUNCS"
done

# === PROMPT USER ===
echo "[INFO] New functions to merge: ${#new_funcs[@]}"
printf '  - %s\n' "${new_funcs[@]}"
read -rp "Append these to $MAIN_SCRIPT? [y/N]: " confirm
[[ "$confirm" =~ ^[Yy]$ ]] || { echo "[ABORTED] Merge canceled."; exit 1; }

# === APPEND NEW FUNCTIONS ===
{
  echo ""
  echo "### === BEGIN MERGED FUNCTIONS FROM $INLINE_SCRIPT @ $timestamp ==="
  cat "$TMP_FUNCS"
  echo "### === END MERGED FUNCTIONS ==="
} >> "$MAIN_SCRIPT"

# === LOG THE MERGE ===
{
  echo "=== Merge @ $timestamp ==="
  echo "From: $INLINE_SCRIPT"
  echo "Into: $MAIN_SCRIPT"
  echo "Added functions:"
  printf '  - %s\n' "${new_funcs[@]}"
  echo "============================"
} >> "$LOG_FILE"

echo "[DONE] Merged ${#new_funcs[@]} functions into $MAIN_SCRIPT"
echo "[LOG] Logged to $LOG_FILE"

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/merge_omniscientctl_inline.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/omniscient_dynamic_menu.sh =====
#!/usr/bin/env bash

OMNI_ROOT="/opt/omniscient"

function list_modules() {
  echo "================= Dynamic Omniscient Modules ================="
  echo "Scanning $OMNI_ROOT for top-level modules..."
  echo
  dirs=()
  for d in "$OMNI_ROOT"/*/; do
    [[ -d "$d" ]] && dirs+=("$(basename "$d")")
  done
  echo "Modules detected: ${#dirs[@]}"
  echo
}

function select_menu() {
  PS3=$'\nSelect a module to explore (or type Ctrl+C to exit): '
  select module in "${dirs[@]}"; do
    if [[ -n "$module" ]]; then
      echo
      echo "🔍 Entering $module..."
      cd "$OMNI_ROOT/$module" || { echo "⚠️ Failed to enter directory."; break; }
      exec bash  # start a subshell in the module dir
    else
      echo "❌ Invalid choice."
    fi
  done
}

list_modules
select_menu

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/omniscient_dynamic_menu.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/omniscientctl_wrappers.bash =====
#!/usr/bin/env bash

# ================================
# Omniscientctl Wrapper Functions
# ================================

# Ensure base path is correct
OMNISCIENTCTL_PATH="/opt/omniscient/control/omniscientctl"

# Check if command exists
function omniscientctl_exists() {
    [[ -x "$OMNISCIENTCTL_PATH" ]]
}

# Core wrapper
function omniscient() {
    omniscientctl_exists || { echo "❌ omniscientctl not found."; return 127; }
    "$OMNISCIENTCTL_PATH" "$@"
}

# =============
# Subcommands
# =============

# Omniscient AI Pipeline
function omni-ai() {
    omniscient ai pipe "$@"
}

# Voice-driven AI development
function omni-voice() {
    omniscient ai voice dev "$@"
}

# AI-enhanced Bash task
function omni-task() {
    omniscient ai task "$@"
}

# OSINT Recon Engine
function omni-osint() {
    omniscient ai osint "$@"
}

# HuggingFace summarizer
function omni-hf() {
    omniscient ai hf summarize "$@"
}

# Backup tool wrapper
function omni-backup() {
    omniscient backupctl "$@"
}

# Modman virtualenv handler
function omni-mods() {
    omniscient modmanctl "$@"
}

# System Sentinel manager
function omni-sentinel() {
    omniscient systemsentinel "$@"
}

# Dynamic disk tool
function omni-disk() {
    omniscient diskai "$@"
}

# Load help and usage
function omni-help() {
    omniscient --help
}

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/omniscientctl_wrappers.bash =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl.d/github.sh =====
#!/usr/bin/env bash

set -e

REPO_DIR="/opt/omniscient"
cd "$REPO_DIR" || { echo "❌ Repo not found: $REPO_DIR"; exit 1; }

function main_menu() {
    clear
    echo "🧠 Omniscient GitHub Setup"
    echo "---------------------------"
    echo "1. Set up SSH Key for GitHub"
    echo "2. Set HTTPS Remote with Token"
    echo "3. Check Git Remote"
    echo "4. Push Current Branch to Origin"
    echo "5. Exit"
    read -rp "Choose an option: " choice

    case $choice in
        1) setup_ssh ;;
        2) setup_https ;;
        3) show_remote ;;
        4) push_branch ;;
        5) exit 0 ;;
        *) echo "Invalid choice"; sleep 1; main_menu ;;
    esac
}

function setup_ssh() {
    echo "🔐 Setting up SSH Key..."
    if [[ ! -f ~/.ssh/id_ed25519 ]]; then
        ssh-keygen -t ed25519 -C "$USER@$(hostname)"
    else
        echo "✅ SSH key already exists."
    fi

    echo "📋 Copy this public key to GitHub:"
    echo "---------------------------"
    cat ~/.ssh/id_ed25519.pub
    echo "---------------------------"
    echo "🔗 Visit: https://github.com/settings/ssh/new"
    read -rp "Press Enter when done..."

    ssh -T git@github.com || echo "⚠️ SSH auth failed. Double-check GitHub settings."

    git remote set-url origin git@github.com:MrSiebel585/omniscient.git
    echo "✅ SSH remote set."
    pause
}

function setup_https() {
    read -rp "GitHub Username: " GH_USER
    read -rp "Paste your GitHub PAT (Personal Access Token): " -s GH_TOKEN
    echo
    git remote set-url origin https://$GH_USER:$GH_TOKEN@github.com/$GH_USER/omniscient.git

    echo "✅ HTTPS remote set with token."
    git config --global credential.helper store
    echo "💾 Credentials will be remembered in ~/.git-credentials"
    pause
}

function show_remote() {
    echo "🔍 Current Git remote:"
    git remote -v
    pause
}

function push_branch() {
    BRANCH=$(git symbolic-ref --short HEAD)
    echo "🚀 Pushing branch: $BRANCH"
    git add .
    git commit -m "Auto push: $(date '+%F %T')" || echo "📝 No new changes to commit."
    git push origin "$BRANCH"
    pause
}

function pause() {
    read -rp "Press Enter to return to menu..."
    main_menu
}

main_menu

# ===== END: /opt/omniscient/dev/control/omniscientctl.d/github.sh =====

# ===== BEGIN: /opt/omniscient/dev/control/omniscientctl_scaffolding_hook.txt =====
#!/usr/bin/env bash
# omniscientctl - Omniscient system control CLI
# Location: /usr/local/bin/omniscientctl
# Description: Unified command entrypoint for framework, modules, dashboards, agents

OMNI_HOME="/opt/omniscient"
LOG="$OMNI_HOME/logs/omniscientctl.log"
MANIFEST="$OMNI_HOME/omniscient_manifest.csv"

log() {
  echo "[omniscientctl] $1" | tee -a "$LOG"
}

case "$1" in
  install|install-all)
    log "Running install hooks..."
    find "$OMNI_HOME" -name install.sh -exec bash {} \;
    ;;
  init|init-all)
    log "Running init hooks..."
    find "$OMNI_HOME" -name init.sh -exec bash {} \;
    ;;
  install-scan)
    log "Scanning directories for install/init scripts..."
    echo "Module,Init Found,Install Found" > "$OMNI_HOME/logs/install_scan_report.csv"
    for d in $(find "$OMNI_HOME" -mindepth 1 -maxdepth 3 -type d); do
      init="❌"
      install="❌"
      [[ -f "$d/init.sh" ]] && init="✅"
      [[ -f "$d/install.sh" ]] && install="✅"
      echo "$(basename "$d"),$init,$install" >> "$OMNI_HOME/logs/install_scan_report.csv"
    done
    log "Install scan complete. Report: $OMNI_HOME/logs/install_scan_report.csv"
    ;;
  script|script-scan)
    log "Checking for logging wrappers..."
    bash "$OMNI_HOME/init/inject_logging_wrapper.sh" --scan
    ;;
  manifest|manifest-rebuild)
    log "Rebuilding manifest..."
    echo "File,Category,Path,Checksum" > "$MANIFEST"
    find "$OMNI_HOME" -type f \( -name "*.sh" -o -name "*.py" \) | while read -r f; do
      base=$(basename "$f")
      cat=$(echo "$f" | grep -Eo '(ai|init|web|scripts|config|sql|bin|modules)' | head -n1)
      sum=$(md5sum "$f" | awk '{print $1}')
      echo "$base,$cat,$f,$sum" >> "$MANIFEST"
    done
    log "Manifest rebuilt at $MANIFEST"
    ;;
  dashboard|launch-dashboard)
    log "Launching unified dashboard..."
    streamlit run "$OMNI_HOME/web/unified_dashboard.py"
    ;;
  voice|voice-listen)
    log "Activating voice agent..."
    python3 "$OMNI_HOME/ai/voice_agent_upgraded.py"
    ;;
  help|--help|-h|"")
    echo "Omniscient System CLI"
    echo "Usage:"
    echo "  omniscientctl install-scan     # Scan modules for init/install"
    echo "  omniscientctl init-all         # Run all init.sh"
    echo "  omniscientctl install-all      # Run all install.sh"
    echo "  omniscientctl manifest-rebuild # Rebuild file manifest"
    echo "  omniscientctl script-scan      # Check/add logging to all scripts"
    echo "  omniscientctl launch-dashboard # Launch unified dashboard"
    echo "  omniscientctl voice-listen     # Activate voice agent"
    ;;
  *)
    echo "[!] Unknown command: $1"
    ;;
esac

# ===== END: /opt/omniscient/dev/control/omniscientctl_scaffolding_hook.txt =====
# ===== Dispatcher (fall-through safe) =====
show_help(){
cat <<'HLP'
Usage: omniscientctl <command> [args]
Try:   omniscientctl verify-completion
HLP
}

verify_completion_cmd(){
  echo "=== omniscientctl verify-completion ==="
  echo "[whoami] $(whoami)"
  echo "[path]   $(command -v omniscientctl)"
  echo
  echo "[subs]    $(omniscientctl __comp subs 2>/dev/null || true)"
  echo "[opts]    $(omniscientctl __comp opts __base 2>/dev/null || true)"
  echo "[engines] $(omniscientctl __comp engines 2>/dev/null || true)"
  echo "[devices] $(omniscientctl __comp devices 2>/dev/null || true)"
}

cmd="${1:-}"; shift || true
case "$cmd" in
  help|"")           show_help ;;
  verify-completion) verify_completion_cmd ;;
  backbone)          : ;;  # your existing handlers can be present in sources
  bootstrap)         : ;;
  mysql)             : ;;
  rsyslog)           : ;;
  drives)            : ;;
  prompt)            : ;;
  summarize)         : ;;
  install|update|backup|start|stop|restart|exec|launch|gui|streamlit|launch-ui|omnieye|shell-review|version|legend|pick|logs|migrate)
                      : ;;
  __comp)            : ;; # already handled above
  *)
    # module passthrough
    if [[ -n "${MODULES[$cmd]:-}" ]]; then
      "${MODULES[$cmd]}" "$@"
    else
      echo "Unknown command: $cmd" >&2
      exit 1
    fi
    ;;
esac
jeremy@raspberrypi:~$
